<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<rules>
   <builtin>
      <category description="Coding Conventions" name="CODSTA">
         <rule header="Array elements shall be accessed by the array operator [ ]" id="01" impl="CODSTA-01" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-01.rule"/>
         </rule>
         <rule header="Do not declare member variables as bit-fields" id="02" impl="CODSTA-02" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-02.rule"/>
         </rule>
         <rule header="Do not define constants via #define" id="03" impl="CODSTA-03" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-03.rule"/>
         </rule>
         <rule header="Do not declare local variables with the 'static' keyword" id="04" impl="CODSTA-04" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-04.rule"/>
         </rule>
         <rule header="Pointers to pointers should be avoided whenever possible" id="05" impl="CODSTA-05" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-05.rule"/>
         </rule>
         <rule header="Avoid using the '?:' operator" id="06" impl="CODSTA-06" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-06.rule"/>
         </rule>
         <rule header="If a function has no parameters, use ( ) instead of ( void )" id="07" impl="CODSTA-07" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-07.rule"/>
         </rule>
         <rule header="Do not use break in for loops" id="08" impl="CODSTA-08" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-08.rule"/>
         </rule>
         <rule header="Do not cast pointers to functions to pointers to primitive types" id="09" impl="CODSTA-09" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-09.rule"/>
         </rule>
         <rule header="Storage type modifiers shall be associated with the type, not the variable or the function" id="10" impl="CODSTA-10" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-10.rule"/>
         </rule>
         <rule header="Signed and unsigned values shall not be mixed in arithmetic operations" id="100" impl="CODSTA-100" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-100.rule"/>
         </rule>
         <rule header="Signed and unsigned values shall not be mixed in second and third operand of conditional operator" id="101" impl="CODSTA-101" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-101.rule"/>
         </rule>
         <rule header="A single operation with side-effect shall only be used in the proper context" id="102" impl="CODSTA-102" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-102.rule"/>
         </rule>
         <rule header="A call of function with side-effect shall only be used in the proper context" id="103" impl="CODSTA-103" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-103.rule"/>
         </rule>
         <rule header="The operands of a logical &amp;&amp; or || shall be parenthesized if the operands contain binary operators" id="104" impl="CODSTA-104" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-104.rule"/>
         </rule>
         <rule header="The second or third operand of a ternary operator '?:' shall not contain side effects" id="105" impl="CODSTA-105" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-105.rule"/>
         </rule>
         <rule header="The library functions bsearch and qsort of &lt;stdlib.h&gt; shall not be used" id="107" impl="CODSTA-107" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-107.rule"/>
         </rule>
         <rule header="The standard header file &lt;tgmath.h&gt; shall not be used" id="108" impl="CODSTA-108" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-108.rule"/>
         </rule>
         <rule header="The exception handling features of &lt;fenv.h&gt; should not be used" id="109" impl="CODSTA-109" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-109.rule"/>
         </rule>
         <rule header="Assert liberally to document internal assumptions and invariants" id="11" impl="CODSTA-11" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-11.rule"/>
         </rule>
         <rule header="The Standard Library input/output functions shall not be used" id="110" impl="CODSTA-110" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-110.rule"/>
         </rule>
         <rule header="The union keyword should not be used" id="111" impl="CODSTA-111" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-111.rule"/>
         </rule>
         <rule header="Variable-length array types shall not be used" id="112" impl="CODSTA-112" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-112.rule"/>
         </rule>
         <rule header="Flexible array members shall not be declared" id="113" impl="CODSTA-113" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-113.rule"/>
         </rule>
         <rule header="Assembly language shall be encapsulated and isolated in C/C++ functions" id="114" impl="CODSTA-114" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-114.rule"/>
         </rule>
         <rule header="If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden" id="115" impl="CODSTA-115" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-115.rule"/>
         </rule>
         <rule header="A 'default' label, if it exists, shall appear as either the first or the last switch label of a switch statement" id="116" impl="CODSTA-116" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-116.rule"/>
         </rule>
         <rule header="Octal and hexadecimal escape sequences shall be terminated" id="117" impl="CODSTA-117" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-117.rule"/>
         </rule>
         <rule header="A declaration shall be visible when an object or function with external linkage is defined" id="118" impl="CODSTA-118" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-118.rule"/>
         </rule>
         <rule header="A 'default' label shall have a statement or a comment before terminating 'break'" id="119" impl="CODSTA-119" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-119.rule"/>
         </rule>
         <rule header="Avoid using shift operations instead of arithmetic operations" id="12" impl="CODSTA-12" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-12.rule"/>
         </rule>
         <rule header="An inline function shall be declared with the static storage class" id="120" impl="CODSTA-120" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-120.rule"/>
         </rule>
         <rule header="The restrict type qualifier shall not be used" id="121" impl="CODSTA-121" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-121.rule"/>
         </rule>
         <rule header="The value returned by a function having non-void return type shall be used" id="122_a" impl="CODSTA-122_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-122_a.rule"/>
         </rule>
         <rule header="The value returned by a function having non-void return type shall be used" id="122_b" impl="CODSTA-122_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-122_b.rule"/>
         </rule>
         <rule header="A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects" id="123" impl="CODSTA-123" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-123.rule"/>
         </rule>
         <rule header="Conversions shall not be performed between a pointer to a function and any other type than pointer to function" id="124_a" impl="CODSTA-124_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-124_a.rule"/>
         </rule>
         <rule header="Conversions shall not be performed between non compatible pointer to a function types" id="124_b" impl="CODSTA-124_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-124_b.rule"/>
         </rule>
         <rule header="Conversions shall not be performed between a pointer to an incomplete type and any other type" id="125" impl="CODSTA-125" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-125.rule"/>
         </rule>
         <rule header="A cast shall not be performed between a pointer to object type and a pointer to a different object type" id="126" impl="CODSTA-126" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-126.rule"/>
         </rule>
         <rule header="A conversion should not be performed between a pointer to object and an integer type" id="127" impl="CODSTA-127" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-127.rule"/>
         </rule>
         <rule header="A conversion should not be performed between a pointer to object type and an integer type other than 'uintptr_t' or 'intptr_t'" id="127_b" impl="CODSTA-127_b" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-127_b.rule"/>
         </rule>
         <rule header="A conversion should not be performed from pointer to void into pointer to object" id="128" impl="CODSTA-128" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-128.rule"/>
         </rule>
         <rule header="A cast shall not be performed between pointer to void and an arithmetic type" id="129_a" impl="CODSTA-129_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-129_a.rule"/>
         </rule>
         <rule header="An implicit conversion shall not be performed between pointer to void and an arithmetic type" id="129_b" impl="CODSTA-129_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-129_b.rule"/>
         </rule>
         <rule header="Avoid pointer arithmetic" id="13" impl="CODSTA-13" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-13.rule"/>
         </rule>
         <rule header="A cast shall not be performed between pointer to object and a non-integer arithmetic type" id="130" impl="CODSTA-130" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-130.rule"/>
         </rule>
         <rule header="Use NULL instead of literal zero (0) as the null-pointer-constant" id="131" impl="CODSTA-131" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-131.rule"/>
         </rule>
         <rule header="A function parameter should not be modified" id="132" impl="CODSTA-132" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-132.rule"/>
         </rule>
         <rule header="A macro shall not be defined with the same name as a keyword in C90" id="133_a" impl="CODSTA-133_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-133_a.rule"/>
         </rule>
         <rule header="A macro shall not be defined with the same name as a keyword in C99" id="133_b" impl="CODSTA-133_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-133_b.rule"/>
         </rule>
         <rule header="The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements" id="134" impl="CODSTA-134" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-134.rule"/>
         </rule>
         <rule header="Type casting from any type to or from pointers shall not be used" id="135" impl="CODSTA-135" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-135.rule"/>
         </rule>
         <rule header="The identifiers va_list, va_arg, va_start, va_end, va_copy should not be used" id="136_a" impl="CODSTA-136_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-136_a.rule"/>
         </rule>
         <rule header="The identifiers va_list, va_arg, va_start, va_end should not be used" id="136_b" impl="CODSTA-136_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-136_b.rule"/>
         </rule>
         <rule header="The function call shall not be the operand of the sizeof operator" id="137" impl="CODSTA-137" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-137.rule"/>
         </rule>
         <rule header="The result of a built-in assignment operator should not be used" id="138" impl="CODSTA-138" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-138.rule"/>
         </rule>
         <rule header="Never convert consts to non-consts" id="14" impl="CODSTA-14" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-14.rule"/>
         </rule>
         <rule header="Initializer lists shall not contain persistent side effects" id="141_a" impl="CODSTA-141_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-141_a.rule"/>
         </rule>
         <rule header="Global functions shall not declare parameters with array type" id="142" impl="CODSTA-142" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-142.rule"/>
         </rule>
         <rule header="Functions which are called with array argument shall not be declared with pointer parameter" id="142_b" impl="CODSTA-142_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-142_b.rule"/>
         </rule>
         <rule header="Suspicious use of 'strcpy' without checking size of source buffer" id="143" impl="CODSTA-143" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-143.rule"/>
         </rule>
         <rule header="The values returned by functions 'read' and 'readlink' shall be used" id="144" impl="CODSTA-144" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-144.rule"/>
         </rule>
         <rule header="Use of possibly not null-terminated string with functions expecting null-terminated string" id="145" impl="CODSTA-145" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-145.rule"/>
         </rule>
         <rule header="A value returned from a stdio character-oriented I/O function should not be implicitly converted to a type smaller than 'int'" id="146" impl="CODSTA-146" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-146.rule"/>
         </rule>
         <rule header="Pointer should not be compared with NULL using relational operators &lt;, &gt;, &gt;=, &lt;=" id="147" impl="CODSTA-147" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-147.rule"/>
         </rule>
         <rule header="Do not use string literals as operands of equality or relational operators" id="148" impl="CODSTA-148" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-148.rule"/>
         </rule>
         <rule header="Missing break statement between cases in a switch statement" id="149" impl="CODSTA-149" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-149.rule"/>
         </rule>
         <rule header="Do not declare the size of an array when the array is passed into a function as a parameter" id="15" impl="CODSTA-15" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-15.rule"/>
         </rule>
         <rule header="Assertions should not contain assignments, increment, or decrement operators" id="150" impl="CODSTA-150" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-150.rule"/>
         </rule>
         <rule header="Assertions should not contain function calls nor function-like macro calls" id="150_b" impl="CODSTA-150_b" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-150_b.rule"/>
         </rule>
         <rule header="Avoid side effects in arguments to unsafe macros" id="150_c" impl="CODSTA-150_c" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-150_c.rule"/>
         </rule>
         <rule header="Do not use enumerations in boolean condition" id="151" impl="CODSTA-151" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-151.rule"/>
         </rule>
         <rule header="The value of a composite expression shall not be cast to a different essential type category or a wider essential type" id="152" impl="CODSTA-152" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-152.rule"/>
         </rule>
         <rule header="An external object or function shall not have more than one non-defining declaration in translation unit" id="154" impl="CODSTA-154" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-154.rule"/>
         </rule>
         <rule header="Use typedefs from stdint.h instead of declaring your own in C99 code" id="155" impl="CODSTA-155" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-155.rule"/>
         </rule>
         <rule header="If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type" id="156_a" impl="CODSTA-156_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-156_a.rule"/>
         </rule>
         <rule header="If a composite expression is used as one (second or third) operand of a conditional operator then the other operand shall not have wider essential type" id="156_b" impl="CODSTA-156_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-156_b.rule"/>
         </rule>
         <rule header="The value of a composite expression shall not be assigned to an object with wider essential type" id="157" impl="CODSTA-157" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-157.rule"/>
         </rule>
         <rule header="Function types shall have named parameters" id="158" impl="CODSTA-158" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-158.rule"/>
         </rule>
         <rule header="Function types shall be in prototype form" id="159" impl="CODSTA-159" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-159.rule"/>
         </rule>
         <rule header="Do not declare the size of an array when the array is initialized" id="16" impl="CODSTA-16" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-16.rule"/>
         </rule>
         <rule header="The declaration of an array parameter shall not contain the 'static' keyword between the [ ]" id="160" impl="CODSTA-160" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-160.rule"/>
         </rule>
         <rule header="An expression of essentially Boolean type should always be used where an operand is interpreted as a Boolean value" id="161_a" impl="CODSTA-161_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_a.rule"/>
         </rule>
         <rule header="An operand of essentially Boolean type should not be used where an operand is interpreted as a numeric value" id="161_b" impl="CODSTA-161_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_b.rule"/>
         </rule>
         <rule header="An operand of essentially character type should not be used where an operand is interpreted as a numeric value" id="161_c" impl="CODSTA-161_c" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_c.rule"/>
         </rule>
         <rule header="An operand of essentially enum type should not be used in an arithmetic operation" id="161_d" impl="CODSTA-161_d" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_d.rule"/>
         </rule>
         <rule header="Shift and bitwise operations should not be performed on operands of essentially signed or enum type" id="161_e" impl="CODSTA-161_e" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_e.rule"/>
         </rule>
         <rule header="An operand of essentially signed or enum type should not be used as the right hand operand to the bitwise shifting operator" id="161_f" impl="CODSTA-161_f" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_f.rule"/>
         </rule>
         <rule header="An operand of essentially unsigned type should not be used as the operand to the unary minus operator" id="161_g" impl="CODSTA-161_g" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_g.rule"/>
         </rule>
         <rule header="Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations" id="162" impl="CODSTA-162" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-162.rule"/>
         </rule>
         <rule header="The value of an expression shall not be assigned to an object with a narrower essential type" id="163_a" impl="CODSTA-163_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-163_a.rule"/>
         </rule>
         <rule header="The value of an expression shall not be assigned to an object of a different essential type category" id="163_b" impl="CODSTA-163_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-163_b.rule"/>
         </rule>
         <rule header="Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category" id="164_a" impl="CODSTA-164_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-164_a.rule"/>
         </rule>
         <rule header="The second and third operands of the ternary operator shall have the same essential type category" id="164_b" impl="CODSTA-164_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-164_b.rule"/>
         </rule>
         <rule header="The cast operation to essentially enumeration type is not allowed" id="165_a" impl="CODSTA-165_a" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-165_a.rule"/>
         </rule>
         <rule header="Do not cast from or to essentially Boolean type" id="165_b" impl="CODSTA-165_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-165_b.rule"/>
         </rule>
         <rule header="Do not use casts between essentially character types and essentially floating types" id="165_c" impl="CODSTA-165_c" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-165_c.rule"/>
         </rule>
         <rule header="A pointer to a FILE object shall not be dereferenced" id="166_a" impl="CODSTA-166_a" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-166_a.rule"/>
         </rule>
         <rule header="A pointer to a FILE object shall not be dereferenced by a library function" id="166_b" impl="CODSTA-166_b" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-166_b.rule"/>
         </rule>
         <rule header="A loop counter in a 'for' loop shall not have essentially floating type" id="167_a" impl="CODSTA-167_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-167_a.rule"/>
         </rule>
         <rule header="A loop counter in 'while' and 'do-while' loops shall not have essentially floating type" id="167_b" impl="CODSTA-167_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-167_b.rule"/>
         </rule>
         <rule header="There shall only be one loop counter in a 'for' loop, which shall not be modified in the 'for' loop body" id="168" impl="CODSTA-168" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-168.rule"/>
         </rule>
         <rule header="The first clause of a 'for' loop shall be well-formed" id="169_a" impl="CODSTA-169_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-169_a.rule"/>
         </rule>
         <rule header="The second clause of a 'for' loop shall be well-formed" id="169_b" impl="CODSTA-169_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-169_b.rule"/>
         </rule>
         <rule header="The third clause of a 'for' statement shall be well-formed" id="169_c" impl="CODSTA-169_c" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-169_c.rule"/>
         </rule>
         <rule header="Do not use NULL identifier; use 0 instead" id="17" impl="CODSTA-17" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-17.rule"/>
         </rule>
         <rule header="The names of macros that exist prior to preprocessing should be distinct from the identifiers that exist after preprocessing (c90)" id="170_c90" impl="CODSTA-170_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-170_c90.rule"/>
         </rule>
         <rule header="The names of macros that exist prior to preprocessing should be distinct from the identifiers that exist after preprocessing (c99)" id="170_c99" impl="CODSTA-170_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-170_c99.rule"/>
         </rule>
         <rule header="The name of a macro should be distinct from the names of its parameters(c90)" id="171_c90" impl="CODSTA-171_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-171_c90.rule"/>
         </rule>
         <rule header="The name of a macro should be distinct from the names of its parameters(c99)" id="171_c99" impl="CODSTA-171_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-171_c99.rule"/>
         </rule>
         <rule header="The name of a macro should be distinct from the names of other macros that are currently defined(c90)" id="172_c90" impl="CODSTA-172_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-172_c90.rule"/>
         </rule>
         <rule header="The name of a macro should be distinct from the names of other macros that are currently defined(c99)" id="172_c99" impl="CODSTA-172_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-172_c99.rule"/>
         </rule>
         <rule header="A program should not exceed the translation limits imposed by The Standard (c90)" id="174_a_c90" impl="CODSTA-174_a_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-174_a_c90.rule"/>
         </rule>
         <rule header="A program should not exceed the translation limits imposed by The Standard (c99)" id="174_a_c99" impl="CODSTA-174_a_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-174_a_c99.rule"/>
         </rule>
         <rule header="A program should not exceed the translation limits imposed by The Standard (c90)" id="174_b_c90" impl="CODSTA-174_b_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-174_b_c90.rule"/>
         </rule>
         <rule header="A program should not exceed the translation limits imposed by The Standard (c99)" id="174_b_c99" impl="CODSTA-174_b_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-174_b_c99.rule"/>
         </rule>
         <rule header="A function should not contain unused type declarations" id="175_a" impl="CODSTA-175_a" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-175_a.rule"/>
         </rule>
         <rule header="A source file should not contain unused type declarations" id="175_b" impl="CODSTA-175_b" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-175_b.rule"/>
         </rule>
         <rule header="A function should not contain unused local tag declarations" id="176_a" impl="CODSTA-176_a" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-176_a.rule"/>
         </rule>
         <rule header="A source file should not contain unused tag declarations" id="176_b" impl="CODSTA-176_b" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-176_b.rule"/>
         </rule>
         <rule header="A source file should not contain unused macro declarations" id="177" impl="CODSTA-177" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-177.rule"/>
         </rule>
         <rule header="External identifiers shall be distinct" id="178" impl="CODSTA-178" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-178.rule"/>
         </rule>
         <rule header="Identifiers declared in the file scope and in the same name space shall be distinct (c90)" id="179_a_c90" impl="CODSTA-179_a_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-179_a_c90.rule"/>
         </rule>
         <rule header="Identifiers declared in the file scope and in the same name space shall be distinct (c99)" id="179_a_c99" impl="CODSTA-179_a_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-179_a_c99.rule"/>
         </rule>
         <rule header="Identifiers declared in the same block scope and name space shall be distinct (c90)" id="179_b_c90" impl="CODSTA-179_b_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-179_b_c90.rule"/>
         </rule>
         <rule header="Identifiers declared in the same block scope and name space shall be distinct (c99)" id="179_b_c99" impl="CODSTA-179_b_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-179_b_c99.rule"/>
         </rule>
         <rule header="Prefer while statements over do statements" id="18" impl="CODSTA-18" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-18.rule"/>
         </rule>
         <rule header="Identifiers that define objects or functions with external linkage shall be unique" id="180" impl="CODSTA-180" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-180.rule"/>
         </rule>
         <rule header="The +, -, += and -= operators should not be applied to an expression of pointer type" id="181" impl="CODSTA-181" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-181.rule"/>
         </rule>
         <rule header="The 'sizeof' operator shall not have an operand which is a function parameter declared as &quot;array of type&quot;" id="182" impl="CODSTA-182" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-182.rule"/>
         </rule>
         <rule header="The pointer arguments to the Standard Library functions 'memcmp', 'memmove' and 'memcmp' shall be pointers to qualified or unqualified versions of compatible types" id="183" impl="CODSTA-183" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-183.rule"/>
         </rule>
         <rule header="The pointer arguments to the Standard Library function 'memcmp' shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type" id="184" impl="CODSTA-184" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-184.rule"/>
         </rule>
         <rule header="The pointers returned by the Standard Library functions 'localeconv', 'getenv', 'setlocale' or, 'strerror' shall only be used as if they have pointer to const-qualified type" id="185_a" impl="CODSTA-185_a" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-185_a.rule"/>
         </rule>
         <rule header="Strings pointed by members of the structure 'lconv' should not be modified" id="185_b" impl="CODSTA-185_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-185_b.rule"/>
         </rule>
         <rule header="Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly" id="186" impl="CODSTA-186" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-186.rule"/>
         </rule>
         <rule header="Cast characters to unsigned char before assignment to larger integer sizes" id="187_a" impl="CODSTA-187_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-187_a.rule"/>
         </rule>
         <rule header="An expressions of the 'signed char' type should not be used as an array index" id="187_b" impl="CODSTA-187_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-187_b.rule"/>
         </rule>
         <rule header="Cast characters to unsigned char before converting to larger integer sizes" id="187_c" impl="CODSTA-187_c" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-187_c.rule"/>
         </rule>
         <rule header="Do not confuse narrow and wide character strings and functions" id="188" impl="CODSTA-188" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-188.rule"/>
         </rule>
         <rule header="Do not add or subtract a scaled integer to a pointer" id="189" impl="CODSTA-189" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-189.rule"/>
         </rule>
         <rule header="Use the ctype.h facilities for character test" id="19" impl="CODSTA-19" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-19.rule"/>
         </rule>
         <rule header="Do not use object representations to compare floating-point values" id="190" impl="CODSTA-190" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-190.rule"/>
         </rule>
         <rule header="Wrap functions that can spuriously wake up in a loop" id="191" impl="CODSTA-191" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-191.rule"/>
         </rule>
         <rule header="The final member of a structure should not be an array of size '0' or '1'" id="192" impl="CODSTA-192" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-192.rule"/>
         </rule>
         <rule header="Allocate structures containing a flexible array member dynamically" id="193" impl="CODSTA-193" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-193.rule"/>
         </rule>
         <rule header="Wrap functions that can fail spuriously in a loop" id="194" impl="CODSTA-194" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-194.rule"/>
         </rule>
         <rule header="Do not refer to an atomic variable twice in an expression" id="195" impl="CODSTA-195" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-195.rule"/>
         </rule>
         <rule header="Do not access an array in the result of a function call" id="196" impl="CODSTA-196" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-196.rule"/>
         </rule>
         <rule header="Do not specify the bound of a character array initialized with a string literal" id="197" impl="CODSTA-197" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-197.rule"/>
         </rule>
         <rule header="The value of a complex expression of floating type may only be cast to a narrower floating type" id="198" impl="CODSTA-198" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-198.rule"/>
         </rule>
         <rule header="Do not use assertions" id="199" impl="CODSTA-199" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-199.rule"/>
         </rule>
         <rule header="EOS should be used to terminate a string rather than NULL" id="20" impl="CODSTA-20" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-20.rule"/>
         </rule>
         <rule header="Explicitly specify array bounds in array declarations with initializers" id="200" impl="CODSTA-200" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-200.rule"/>
         </rule>
         <rule header="Do not process structured text data natively" id="201" impl="CODSTA-201" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-201.rule"/>
         </rule>
         <rule header="An inline definition of a function with external linkage shall not contain definitions and uses of static objects" id="202" impl="CODSTA-202" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-202.rule"/>
         </rule>
         <rule header="Do not hard code string literals" id="203" impl="CODSTA-203" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-203.rule"/>
         </rule>
         <rule header="When using enum, the values of each member should be explicitly declared" id="21" impl="CODSTA-21" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-21.rule"/>
         </rule>
         <rule header="Local variable or parameter names and class member variable or parent class/struct member variable names shall differ by more than a single character" id="22" impl="CODSTA-22" quickfix="false" scope="line" severity="1">
            <file path="CODSTA\CODSTA-22.rule"/>
         </rule>
         <rule header="All 'if' statements should have an 'else' clause" id="23" impl="CODSTA-23" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-23.rule"/>
         </rule>
         <rule header="The macro FALSE should be defined as 0 (zero)" id="24" impl="CODSTA-24" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-24.rule"/>
         </rule>
         <rule header="The enumeration constant named 'FALSE' should be explicitly initialized by 0 value" id="25" impl="CODSTA-25" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-25.rule"/>
         </rule>
         <rule header="Avoid magic numbers" id="26" impl="CODSTA-26" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-26.rule"/>
         </rule>
         <rule header="Avoid functions that modify global variables" id="27" impl="CODSTA-27" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-27.rule"/>
         </rule>
         <rule header="Define fields for union declarations" id="28" impl="CODSTA-28" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-28.rule"/>
         </rule>
         <rule header="&quot;#define&quot; or enum constants should be used instead of hard coded values whenever possible" id="29" impl="CODSTA-29" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-29.rule"/>
         </rule>
         <rule header="Avoid returning handles to function parameters" id="30" impl="CODSTA-30" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-30.rule"/>
         </rule>
         <rule header="Avoid explicit type conversions (casts)" id="31" impl="CODSTA-31" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-31.rule"/>
         </rule>
         <rule header="Do not write logical expressions of the type if(test) or if(!test)  when test is a pointer" id="32" impl="CODSTA-32" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-32.rule"/>
         </rule>
         <rule header="Do not use operator ++ or -- in the conditional expression of if, while, or switch" id="33" impl="CODSTA-33" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-33.rule"/>
         </rule>
         <rule header="Use a typedef to simplify program syntax when declaring function pointers" id="34" impl="CODSTA-34" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-34.rule"/>
         </rule>
         <rule header="Always provide a default branch for switch statements" id="35" impl="CODSTA-35" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-35.rule"/>
         </rule>
         <rule header="Pass built-in-types by value unless you are modifying them" id="36" impl="CODSTA-36" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-36.rule"/>
         </rule>
         <rule header="Prefer const objects or enums to #defines for simple constants" id="37" impl="CODSTA-37" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-37.rule"/>
         </rule>
         <rule header="Do not use a #define that prevents the compiler from checking types" id="38" impl="CODSTA-38" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-38.rule"/>
         </rule>
         <rule header="Avoid internal or external name conflict with a C++ reserved word" id="39" impl="CODSTA-39" quickfix="false" scope="line" severity="1">
            <file path="CODSTA\CODSTA-39.rule"/>
         </rule>
         <rule header="'void' should be used when a function is passed or returns no values" id="40" impl="CODSTA-40" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-40.rule"/>
         </rule>
         <rule header="Avoid switch statements with only one case" id="41" impl="CODSTA-41" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-41.rule"/>
         </rule>
         <rule header="The macro TRUE should be defined as 1" id="42" impl="CODSTA-42" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-42.rule"/>
         </rule>
         <rule header="The enumeration constant named 'TRUE' should be explicitly initialized by 1 value" id="43" impl="CODSTA-43" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-43.rule"/>
         </rule>
         <rule header="Local variables should not use the same names as member variables" id="44" impl="CODSTA-44" quickfix="false" scope="line" severity="1">
            <file path="CODSTA\CODSTA-44.rule"/>
         </rule>
         <rule header="Parameters should not use the same names as member variables" id="45" impl="CODSTA-45" quickfix="false" scope="line" severity="1">
            <file path="CODSTA\CODSTA-45.rule"/>
         </rule>
         <rule header="Use positive logic rather than negative logic whenever practical" id="46" impl="CODSTA-46" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-46.rule"/>
         </rule>
         <rule header="All structures should be typedef'd" id="47" impl="CODSTA-47" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-47.rule"/>
         </rule>
         <rule header="The following digraphs will not be used &lt;%, %&gt;, &lt;:, :&gt;, %:, %:%:" id="48" impl="CODSTA-48" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-48.rule"/>
         </rule>
         <rule header="Null initialize or increment expressions in for loops will not be used; a while loop will be used instead" id="49" impl="CODSTA-49" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-49.rule"/>
         </rule>
         <rule header="Hexadecimal constants will be represented using all uppercase letters" id="50" impl="CODSTA-50" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-50.rule"/>
         </rule>
         <rule header="Literal suffixes shall use uppercase rather than lowercase letters" id="51" impl="CODSTA-51" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-51.rule"/>
         </rule>
         <rule header="The initialization expression in a for loop will perform no actions other than to initialize the value of a single for loop parameter" id="52" impl="CODSTA-52" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-52.rule"/>
         </rule>
         <rule header="The increment expression in a for loop will perform no action other than to change a single loop parameter to the next value for the loop" id="53" impl="CODSTA-53" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-53.rule"/>
         </rule>
         <rule header="Every switch statement will have at least two cases and a potential default" id="54" impl="CODSTA-54" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-54.rule"/>
         </rule>
         <rule header="Enumeration types shall be used instead of integer types (and constants) as case labels" id="55" impl="CODSTA-55" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-55.rule"/>
         </rule>
         <rule header="All 'case' and 'default' labels of 'switch' statement should have an explicit 'break' or a 'return' statement, or 'fall through' comment" id="56" impl="CODSTA-56" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-56.rule"/>
         </rule>
         <rule header="Suspicious use of semicolon" id="57" impl="CODSTA-57" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-57.rule"/>
         </rule>
         <rule header="Cast to void is not allowed" id="58" impl="CODSTA-58" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-58.rule"/>
         </rule>
         <rule header="Hardcoded array declarations and 'malloc' calls should not be used" id="59" impl="CODSTA-59" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-59.rule"/>
         </rule>
         <rule header="Avoid comparing values with TRUE macro/enum constant using equality operators (&quot;==&quot;, &quot;!=&quot;)" id="60" impl="CODSTA-60" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-60.rule"/>
         </rule>
         <rule header="The final clause of a switch statement shall be the default-clause unless all enumeration values are tested" id="61" impl="CODSTA-61" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-61.rule"/>
         </rule>
         <rule header="A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type" id="62" impl="CODSTA-62" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-62.rule"/>
         </rule>
         <rule header="Bitwise operators shall only be applied to operands of unsigned underlying type" id="63" impl="CODSTA-63" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-63.rule"/>
         </rule>
         <rule header="An unconditional throw or break statement shall terminate every non-empty switch-clause" id="64" impl="CODSTA-64" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-64.rule"/>
         </rule>
         <rule header="An object with integer type or pointer to void type shall not be converted to an object with pointer type" id="65" impl="CODSTA-65" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-65.rule"/>
         </rule>
         <rule header="Non-constant operands to a binary bitwise operator shall have the same underlying type" id="66" impl="CODSTA-66" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-66.rule"/>
         </rule>
         <rule header="The types used for an object, a function return type, or a function parameter shall be token-for-token identical in all declarations and re-declarations" id="67" impl="CODSTA-67" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-67.rule"/>
         </rule>
         <rule header="A &quot;U&quot; suffix shall be applied to all octal or hexadecimal integer literals of unsigned type" id="68" impl="CODSTA-68" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-68.rule"/>
         </rule>
         <rule header="Expressions with type (plain) char and wchar_t shall not be used as operands to built-in operators other than  =,  ==, != and the unary &amp; operator" id="69" impl="CODSTA-69" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-69.rule"/>
         </rule>
         <rule header="Expressions with type enum shall not be used as operands to built-in operators other than  [ ],  =, ==, !=, &lt;, &lt;=, &gt;, &gt;=, and the unary &amp; operator" id="70" impl="CODSTA-70" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-70.rule"/>
         </rule>
         <rule header="Named bit-fields with signed integer type shall have a length of more than one bit" id="71" impl="CODSTA-71" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-71.rule"/>
         </rule>
         <rule header="Assembler instructions shall only be introduced using the asm declaration" id="73" impl="CODSTA-73" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-73.rule"/>
         </rule>
         <rule header="Bit-fields shall not have enum type" id="74" impl="CODSTA-74" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-74.rule"/>
         </rule>
         <rule header="Bit-fields shall be either bool type or an explicitly unsigned or signed integral type" id="75" impl="CODSTA-75" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-75.rule"/>
         </rule>
         <rule header="The identifier main shall not be used for a function other than the global function main" id="76" impl="CODSTA-76" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-76.rule"/>
         </rule>
         <rule header="The goto statement shall jump to a label declared later in the same function body" id="77" impl="CODSTA-77" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-77.rule"/>
         </rule>
         <rule header="Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement" id="78" impl="CODSTA-78" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-78.rule"/>
         </rule>
         <rule header="For any iteration statement there shall be no more than one break or goto statement used for loop termination" id="79" impl="CODSTA-79" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-79.rule"/>
         </rule>
         <rule header="The continue statement shall only be used within a well formed for loop" id="80" impl="CODSTA-80" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-80.rule"/>
         </rule>
         <rule header="If a function has internal linkage then all redeclarations shall include the static storage class specifier" id="81" impl="CODSTA-81" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-81.rule"/>
         </rule>
         <rule header="Avoid infinite loops" id="82" impl="CODSTA-82" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-82.rule"/>
         </rule>
         <rule header="Do not use empty infinite loops" id="82_b" impl="CODSTA-82_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-82_b.rule"/>
         </rule>
         <rule header="All loops must have a fixed upper or lower bound" id="83" impl="CODSTA-83" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-83.rule"/>
         </rule>
         <rule header="Avoid exit points within infinite loops" id="85" impl="CODSTA-85" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-85.rule"/>
         </rule>
         <rule header="The validity of parameters must be checked inside each function" id="86" impl="CODSTA-86" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-86.rule"/>
         </rule>
         <rule header="Use no more than one level of dereferencing" id="87" impl="CODSTA-87" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-87.rule"/>
         </rule>
         <rule header="Function pointers are not permitted" id="88" impl="CODSTA-88" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-88.rule"/>
         </rule>
         <rule header="The declaration should not contain more than one level of pointer indirection" id="89" impl="CODSTA-89" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-89.rule"/>
         </rule>
         <rule header="Each operand of a logical '&amp;&amp;' or '||' shall be a postfix-expression" id="90" impl="CODSTA-90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-90.rule"/>
         </rule>
         <rule header="A function shall have at most one exit point" id="91" impl="CODSTA-91" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-91.rule"/>
         </rule>
         <rule header="The names of standard library macros and objects shall not be reused" id="92" impl="CODSTA-92" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-92.rule"/>
         </rule>
         <rule header="Reserved identifiers, macros and functions in the standard library, shall not be defined, redefined or undefined (C90 code)" id="92_a" impl="CODSTA-92_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-92_a.rule"/>
         </rule>
         <rule header="Reserved identifiers, macros and functions in the standard library, shall not be defined, redefined or undefined (C99 code)" id="92_b" impl="CODSTA-92_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-92_b.rule"/>
         </rule>
         <rule header="The names of standard library functions shall not be overridden" id="93" impl="CODSTA-93" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-93.rule"/>
         </rule>
         <rule header="Do not declare pointer or array type" id="94" impl="CODSTA-94" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-94.rule"/>
         </rule>
         <rule header="Do not declare pointer type" id="95" impl="CODSTA-95" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-95.rule"/>
         </rule>
         <rule header="Bit-fields shall have explicitly unsigned integral or enumeration types only" id="96" impl="CODSTA-96" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-96.rule"/>
         </rule>
         <rule header="Use parenthesis to clarify expression order if operators with precedence lower than arithmetic are used" id="97" impl="CODSTA-97" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-97.rule"/>
         </rule>
         <rule header="All 'if...else if' constructs will contain either a final else clause or a comment indicating why a final else clause is not necessary" id="98" impl="CODSTA-98" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-98.rule"/>
         </rule>
         <rule header="Signed and unsigned values shall not be mixed in comparison operations" id="99" impl="CODSTA-99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-99.rule"/>
         </rule>
         <category description="Coding Conventions for C++" name="CPP">
            <rule header="Prefer iostream.h to stdio.h" id="01" impl="CODSTA-CPP-01" quickfix="false" scope="line" severity="5">
               <file path="CODSTA-CPP\CODSTA-CPP-01.rule"/>
            </rule>
            <rule header="Have assignment operator returns a reference to *this; make assignment operator's return type a non-const reference to it's class' type" id="02" impl="CODSTA-CPP-02" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-02.rule"/>
            </rule>
            <rule header="Bitwise operators, comparison operators, logical operators, comma operator should be const" id="03" impl="CODSTA-CPP-03" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-03.rule"/>
            </rule>
            <rule header="Constructors allowing for conversion should be made explicit" id="04" impl="CODSTA-CPP-04" quickfix="false" scope="line" severity="1">
               <file path="CODSTA-CPP\CODSTA-CPP-04.rule"/>
            </rule>
            <rule header="Do not use user-defined conversion functions" id="05" impl="CODSTA-CPP-05" quickfix="false" scope="line" severity="1">
               <file path="CODSTA-CPP\CODSTA-CPP-05.rule"/>
            </rule>
            <rule header="Avoid returning handles to class data from member functions" id="06" impl="CODSTA-CPP-06" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-06.rule"/>
            </rule>
            <rule header="Postfix increment and decrement should be implemented in terms of their prefix counterparts" id="07" impl="CODSTA-CPP-07" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-07.rule"/>
            </rule>
            <rule header="Avoid overloading logical operators AND, OR (&amp;&amp;, ||)" id="08" impl="CODSTA-CPP-08" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-08.rule"/>
            </rule>
            <rule header="Avoid using reinterpret_cast" id="09" impl="CODSTA-CPP-09" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-09.rule"/>
            </rule>
            <rule header="Do not define structs that contain member functions" id="10" impl="CODSTA-CPP-10" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-10.rule"/>
            </rule>
            <rule header="Do not compare objects of a class that may contain padding bits with C standard library functions" id="100" impl="CODSTA-CPP-100" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-100.rule"/>
            </rule>
            <rule header="A relational operator shall return a boolean value" id="101" impl="CODSTA-CPP-101" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-101.rule"/>
            </rule>
            <rule header="A binary arithmetic operator and a bitwise operator shall return a 'prvalue'" id="102" impl="CODSTA-CPP-102" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-102.rule"/>
            </rule>
            <rule header="Prefer C++-style casts" id="11" impl="CODSTA-CPP-11" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-11.rule"/>
            </rule>
            <rule header="Put classes that are used as base classes and classes that are used as member variables into separate include files" id="12" impl="CODSTA-CPP-12" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-12.rule"/>
            </rule>
            <rule header="Put classes that are used as function return type into separate include files" id="13" impl="CODSTA-CPP-13" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-13.rule"/>
            </rule>
            <rule header="Put classes that are used as argument types in function prototypes into separate include files" id="14" impl="CODSTA-CPP-14" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-14.rule"/>
            </rule>
            <rule header="Put functions that are used in the body of inline member function into separate include file" id="15" impl="CODSTA-CPP-15" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-15.rule"/>
            </rule>
            <rule header="When two operators are opposites (such as == and !=), it is appropriate to define both" id="16" impl="CODSTA-CPP-16" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-16.rule"/>
            </rule>
            <rule header="Do not use the 'struct' keyword to declare a variable in C++" id="17" impl="CODSTA-CPP-17" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-17.rule"/>
            </rule>
            <rule header="Encapsulate global variables and constants, enumerated types, and typedefs in a class" id="18" impl="CODSTA-CPP-18" quickfix="false" scope="line" severity="5">
               <file path="CODSTA-CPP\CODSTA-CPP-18.rule"/>
            </rule>
            <rule header="Declare at least one constructor to prevent the compiler from doing so" id="19" impl="CODSTA-CPP-19" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-19.rule"/>
            </rule>
            <rule header="If you'd like to support mixed-mode operations make operators a non-member functions" id="20" impl="CODSTA-CPP-20" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-20.rule"/>
            </rule>
            <rule header="Assignment operator must return const reference" id="21" impl="CODSTA-CPP-21" quickfix="false" scope="line" severity="5">
               <file path="CODSTA-CPP\CODSTA-CPP-21.rule"/>
            </rule>
            <rule header="Prefer non-member non-friend functions to member functions" id="22" impl="CODSTA-CPP-22" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-CPP\CODSTA-CPP-22.rule"/>
            </rule>
            <rule header="Whenever a global function  is  referenced, use the :: operator" id="23" impl="CODSTA-CPP-23" quickfix="false" scope="line" severity="5">
               <file path="CODSTA-CPP\CODSTA-CPP-23.rule"/>
            </rule>
            <rule header="Avoid making any assignment operator virtual. Do not return const T&amp; from assignment operator" id="24" impl="CODSTA-CPP-24" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-24.rule"/>
            </rule>
            <rule header="Consider making virtual functions nonpublic, and public functions nonvirtual" id="25" impl="CODSTA-CPP-25" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-25.rule"/>
            </rule>
            <rule header="Keep types and functions in separate namespaces unless they're specifically intended to work together" id="26" impl="CODSTA-CPP-26" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-26.rule"/>
            </rule>
            <rule header="Keep a type and its nonmember function interface in the same namespace" id="27" impl="CODSTA-CPP-27" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-27.rule"/>
            </rule>
            <rule header="When binary arithmetic operators are defined  ( + , - , * , / , ^ , % , | , &amp; ), assignment versions should be provided too" id="28" impl="CODSTA-CPP-28" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-28.rule"/>
            </rule>
            <rule header="Prefer the canonical forms of arithmetic and assignment operators" id="29" impl="CODSTA-CPP-29" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-29.rule"/>
            </rule>
            <rule header="Prefer non-member operators than member ones to support mixed-mode arithmetic" id="30" impl="CODSTA-CPP-30" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-30.rule"/>
            </rule>
            <rule header="Do not use the keyword 'explicit' for a constructor" id="31" impl="CODSTA-CPP-31" quickfix="false" scope="line" severity="5">
               <file path="CODSTA-CPP\CODSTA-CPP-31.rule"/>
            </rule>
            <rule header="Member functions shall not be defined within the no-template class definition" id="32" impl="CODSTA-CPP-32" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-32.rule"/>
            </rule>
            <rule header="Member functions shall not be defined within the template class definition" id="33" impl="CODSTA-CPP-33" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-33.rule"/>
            </rule>
            <rule header="Avoid using static_cast on pointers" id="34" impl="CODSTA-CPP-34" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-34.rule"/>
            </rule>
            <rule header="Avoid dynamic_casts" id="35" impl="CODSTA-CPP-35" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-35.rule"/>
            </rule>
            <rule header="The global namespace shall only contain main() and namespace declarations" id="36" impl="CODSTA-CPP-36" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-36.rule"/>
            </rule>
            <rule header="Do not define class/struct/union inside function implementation" id="37" impl="CODSTA-CPP-37" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-37.rule"/>
            </rule>
            <rule header="Conversion operator, operator-&gt;, operator(), operator[] should be const" id="38" impl="CODSTA-CPP-38" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-38.rule"/>
            </rule>
            <rule header="Don't write namespace usings in a header file or before an #include" id="39" impl="CODSTA-CPP-39" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-39.rule"/>
            </rule>
            <rule header="Limiting the number of objects of a class" id="40" impl="CODSTA-CPP-40" quickfix="false" scope="line" severity="5">
               <file path="CODSTA-CPP\CODSTA-CPP-40.rule"/>
            </rule>
            <rule header="Do not use the 'enum' keyword to declare a variable in C++" id="41" impl="CODSTA-CPP-41" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-41.rule"/>
            </rule>
            <rule header="Do not declare member variables with the 'mutable' keyword" id="42" impl="CODSTA-CPP-42" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-42.rule"/>
            </rule>
            <rule header="Declare reference parameters as const references whenever possible" id="43" impl="CODSTA-CPP-43" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-43.rule"/>
            </rule>
            <rule header="Have the non-const version call the const version of member function instead of duplicating the const version definition" id="44" impl="CODSTA-CPP-44" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-44.rule"/>
            </rule>
            <rule header="In the private section of a class items shall be declared in the following order: Constructors, Destructor, Member Functions, Member Operator Function, Enumerations and others" id="45" impl="CODSTA-CPP-45" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-45.rule"/>
            </rule>
            <rule header="Order of scopes in class: public before all others" id="46" impl="CODSTA-CPP-46" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-46.rule"/>
            </rule>
            <rule header="Order of scopes in classes: protected before private" id="47" impl="CODSTA-CPP-47" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-47.rule"/>
            </rule>
            <rule header="In the protected section of a class items shall be declared in the following order: Constructors, Destructor, Member Functions, Member Operator Function, Enumerations and others" id="48" impl="CODSTA-CPP-48" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-48.rule"/>
            </rule>
            <rule header="In the public section of a class items shall be declared in the following order: Constructors, Destructor, Member Functions, Member Operator Function, Enumerations and others" id="49" impl="CODSTA-CPP-49" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-49.rule"/>
            </rule>
            <rule header="Do not use static keyword except inside functions and classes" id="50" impl="CODSTA-CPP-50" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-50.rule"/>
            </rule>
            <rule header="Do not define inline functions in source files" id="51" impl="CODSTA-CPP-51" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-51.rule"/>
            </rule>
            <rule header="Consider using the natural relationship between the assignment version of an operator and the stand-alone version" id="52" impl="CODSTA-CPP-52" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-52.rule"/>
            </rule>
            <rule header="Declare parameters or local variable as const whenever possible" id="53" impl="CODSTA-CPP-53" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-53.rule"/>
            </rule>
            <rule header="Member functions shall be declared const whenever possible" id="54" impl="CODSTA-CPP-54" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-54.rule"/>
            </rule>
            <rule header="Arrays shall not be used in interfaces" id="55" impl="CODSTA-CPP-55" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-55.rule"/>
            </rule>
            <rule header="Private and protected methods shall not declare parameters with array type" id="55_b" impl="CODSTA-CPP-55_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-55_b.rule"/>
            </rule>
            <rule header="A class, structure, or enumeration will not be declared in the definition of its type" id="56" impl="CODSTA-CPP-56" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-56.rule"/>
            </rule>
            <rule header="Namespaces will not be nested more than two levels deep" id="57" impl="CODSTA-CPP-57" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-57.rule"/>
            </rule>
            <rule header="The value returned by a function having a non-void return type that is not an overloaded operator shall always be used" id="58" impl="CODSTA-CPP-58" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-58.rule"/>
            </rule>
            <rule header="The C library shall not be used" id="59" impl="CODSTA-CPP-59" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-59.rule"/>
            </rule>
            <rule header="Only those escape sequences that are defined in ISO/IEC 14882:2003 shall be used" id="60" impl="CODSTA-CPP-60" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-60.rule"/>
            </rule>
            <rule header="NULL shall not be used as an integer value" id="62" impl="CODSTA-CPP-62" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-62.rule"/>
            </rule>
            <rule header="Literal zero (0) shall not be used as the null-pointer-constant" id="63" impl="CODSTA-CPP-63" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-63.rule"/>
            </rule>
            <rule header="The condition of an if-statement and the condition of an iteration-statement shall have type bool" id="64" impl="CODSTA-CPP-64" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-64.rule"/>
            </rule>
            <rule header="The first operand of a conditional-operator shall have type bool" id="65" impl="CODSTA-CPP-65" quickfix="false" scope="line" severity="1">
               <file path="CODSTA-CPP\CODSTA-CPP-65.rule"/>
            </rule>
            <rule header="C-style casts (other than void casts) and functional notation casts (other than explicit constructor calls) shall not be used" id="66" impl="CODSTA-CPP-66" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-66.rule"/>
            </rule>
            <rule header="Each operand of the ! operator, the logical &amp;&amp; or the logical || operators shall have type bool" id="67" impl="CODSTA-CPP-67" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-67.rule"/>
            </rule>
            <rule header="The unary &amp; operator shall not be overloaded" id="68" impl="CODSTA-CPP-68" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-68.rule"/>
            </rule>
            <rule header="A for loop shall contain a single loop-counter which shall not have floating type" id="69" impl="CODSTA-CPP-69" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-69.rule"/>
            </rule>
            <rule header="If loop-counter is not modified by -- or ++, then, within condition, the loop-counter shall only be used as an operand to &lt;=, &lt;, &gt; or &gt;=" id="70" impl="CODSTA-CPP-70" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-70.rule"/>
            </rule>
            <rule header="The loop-counter shall be modified by one of: --, ++, -=n, or +=n; where n remains constant for the duration of the loop" id="71" impl="CODSTA-CPP-71" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-71.rule"/>
            </rule>
            <rule header="A loop-control-variable other than the loop-counter shall not be modified within condition or expression" id="72" impl="CODSTA-CPP-72" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-72.rule"/>
            </rule>
            <rule header="A loop-control-variable other than the loop-counter which is modified in statement shall have type bool" id="73" impl="CODSTA-CPP-73" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-73.rule"/>
            </rule>
            <rule header="There shall be no unnamed namespaces in header files" id="74" impl="CODSTA-CPP-74" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-74.rule"/>
            </rule>
            <rule header="using-directives shall not be used" id="75" impl="CODSTA-CPP-75" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-75.rule"/>
            </rule>
            <rule header="Multiple declarations for an identifier in the same namespace shall not straddle a using-declaration for that identifier" id="76" impl="CODSTA-CPP-76" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-76.rule"/>
            </rule>
            <rule header="Const member functions shall not return non-const pointers or references to class-data" id="77" impl="CODSTA-CPP-77" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-77.rule"/>
            </rule>
            <rule header="If a member function can be made static then it shall be made static, otherwise if it can be made const then it shall be made const" id="78" impl="CODSTA-CPP-78" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-78.rule"/>
            </rule>
            <rule header="Neither operand of an equality operator (== or !=) shall be a pointer to a virtual member function" id="79" impl="CODSTA-CPP-79" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-79.rule"/>
            </rule>
            <rule header="Avoid overloading comma operator &quot;,&quot;" id="80" impl="CODSTA-CPP-80" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-80.rule"/>
            </rule>
            <rule header="Classes which have only getters/setters (accessors/mutators) are not allowed" id="81" impl="CODSTA-CPP-81" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-CPP\CODSTA-CPP-81.rule"/>
            </rule>
            <rule header="Avoid unencapsulated global variables (including variables declared in namespaces and public static members)" id="82" impl="CODSTA-CPP-82" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-82.rule"/>
            </rule>
            <rule header="Identifiers declared in a local scope should not hide identifiers declared in a class scope" id="83" impl="CODSTA-CPP-83" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-83.rule"/>
            </rule>
            <rule header="Identifiers declared in a class scope should not hide identifiers declared in a global or namespace scope" id="84" impl="CODSTA-CPP-84" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-84.rule"/>
            </rule>
            <rule header="Identifiers declared in an inner class scope should not hide identifiers declared in outer class scope" id="85" impl="CODSTA-CPP-85" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-85.rule"/>
            </rule>
            <rule header="When two operators are opposites (such as == and !=), both will be defined and one will be defined in terms of the other" id="86" impl="CODSTA-CPP-86" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-86.rule"/>
            </rule>
            <rule header="If an identifier refers to a type, it shall not also refer to an object or a function in the same scope" id="87_a" impl="CODSTA-CPP-87_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-87_a.rule"/>
            </rule>
            <rule header="If an identifier refers to a type, it shall not also refer to an object or a function in the same scope" id="87_b" impl="CODSTA-CPP-87_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-87_b.rule"/>
            </rule>
            <rule header="If an identifier refers to a type, it shall not also refer to an object or a function in the same scope" id="87_c" impl="CODSTA-CPP-87_c" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-87_c.rule"/>
            </rule>
            <rule header="The name of typedef should not be the same as the name of its basic type" id="88" impl="CODSTA-CPP-88" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-88.rule"/>
            </rule>
            <rule header="Do not assign enumerations to bool" id="89" impl="CODSTA-CPP-89" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-CPP\CODSTA-CPP-89.rule"/>
            </rule>
            <rule header="using-directives and using-declarations (excluding class scope or function scope using-declarations) shall not be used in header files" id="90" impl="CODSTA-CPP-90" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-90.rule"/>
            </rule>
            <rule header="The overloaded binary operator should be implemented in terms of its corresponding compound assignment operator" id="91" impl="CODSTA-CPP-91" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-91.rule"/>
            </rule>
            <rule header="All accessible entity names within a multiple inheritance hierarchy should be unique" id="92" impl="CODSTA-CPP-92" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-92.rule"/>
            </rule>
            <rule header="Do not initialize objects with a non-trivial class type using C standard library functions" id="93" impl="CODSTA-CPP-93" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-93.rule"/>
            </rule>
            <rule header="Do not compare objects of nonstandard-layout class type with C standard library functions" id="94" impl="CODSTA-CPP-94" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-94.rule"/>
            </rule>
            <rule header="Do not modify the standard namespaces 'std' and 'posix'" id="95" impl="CODSTA-CPP-95" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-95.rule"/>
            </rule>
            <rule header="Do not call a function with a mismatched language linkage" id="96" impl="CODSTA-CPP-96" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-96.rule"/>
            </rule>
            <rule header="Never qualify a reference type with 'const' or 'volatile'" id="97" impl="CODSTA-CPP-97" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-97.rule"/>
            </rule>
            <rule header="Copy operations must not mutate the source object" id="98" impl="CODSTA-CPP-98" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-98.rule"/>
            </rule>
            <rule header="Use offsetof() on valid types and members" id="99" impl="CODSTA-CPP-99" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-99.rule"/>
            </rule>
         </category>
         <category description="Coding Conventions for Modern C++" name="MCPP">
            <rule header="User-conversion cast operators should be made explicit" id="01" impl="CODSTA-MCPP-01" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-01.rule"/>
            </rule>
            <rule header="Prefer alias declarations to typedefs" id="02" impl="CODSTA-MCPP-02" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-02.rule"/>
            </rule>
            <rule header="Prefer Scoped Enums to Unscoped Enums" id="03" impl="CODSTA-MCPP-03" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-03.rule"/>
            </rule>
            <rule header="Prefer 'nullptr' over 'NULL' or '0'(zero)" id="04" impl="CODSTA-MCPP-04" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-04.rule"/>
            </rule>
            <rule header="Declare overriding functions with 'override' specifier" id="05" impl="CODSTA-MCPP-05" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-05.rule"/>
            </rule>
            <rule header="Declare copy constructor and copy assignment operators with the 'delete' specifier to prevent copying of class" id="06_a" impl="CODSTA-MCPP-06_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-06_a.rule"/>
            </rule>
            <rule header="Declare copy constructor and copy assignment operators with the 'delete' specifier instead of using a base class with private methods to prevent copying of class" id="06_b" impl="CODSTA-MCPP-06_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-06_b.rule"/>
            </rule>
            <rule header="Prefer lambdas over std::bind, std::bind1st and std::bind2nd" id="07" impl="CODSTA-MCPP-07" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-07.rule"/>
            </rule>
            <rule header="Prefer 'auto' to explicit type names in variable declarations" id="08_a" impl="CODSTA-MCPP-08_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-08_a.rule"/>
            </rule>
            <rule header="Prefer 'auto' to explicit type names for function return types" id="08_b" impl="CODSTA-MCPP-08_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-08_b.rule"/>
            </rule>
            <rule header="Declare functions 'noexcept' if they will not emit exceptions" id="09" impl="CODSTA-MCPP-09" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-09.rule"/>
            </rule>
            <rule header="Prefer const iterators to iterators" id="10_a" impl="CODSTA-MCPP-10_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-10_a.rule"/>
            </rule>
            <rule header="Prefer to use cbegin(), crbegin, cend(), crend() functions" id="10_b" impl="CODSTA-MCPP-10_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-10_b.rule"/>
            </rule>
            <rule header="Use constexpr to declare const variables whenever possible" id="11_a_cpp11" impl="CODSTA-MCPP-11_a_cpp11" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-11_a_cpp11.rule"/>
            </rule>
            <rule header="Use constexpr to declare functions whenever possible" id="11_b_cpp11" impl="CODSTA-MCPP-11_b_cpp11" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-11_b_cpp11.rule"/>
            </rule>
            <rule header="Use std::move() on rvalue references and std::forward() on forwarding references" id="13" impl="CODSTA-MCPP-13" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-13.rule"/>
            </rule>
            <rule header="Avoid Overloading on Forwarding References" id="14" impl="CODSTA-MCPP-14" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-14.rule"/>
            </rule>
            <rule header="Avoid default capture modes" id="15_a" impl="CODSTA-MCPP-15_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-15_a.rule"/>
            </rule>
            <rule header="Use the 'this' pointer explicitly in lambdas with a default by-reference capture" id="15_b" impl="CODSTA-MCPP-15_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-15_b.rule"/>
            </rule>
            <rule header="Prefer smart pointer members over raw pointer members" id="16_a" impl="CODSTA-MCPP-16_a" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_a.rule"/>
            </rule>
            <rule header="Prefer smart pointers over raw pointers for arrays or STL containers" id="16_b" impl="CODSTA-MCPP-16_b" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_b.rule"/>
            </rule>
            <rule header="Prefer 'std::make_shared' to the direct use of new" id="16_c" impl="CODSTA-MCPP-16_c" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_c.rule"/>
            </rule>
            <rule header="Prefer to use std::unique_ptr instead of std::auto_ptr" id="16_d" impl="CODSTA-MCPP-16_d" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_d.rule"/>
            </rule>
            <rule header="'std::make_unique' shall be used to construct objects owned by 'std::unique_ptr'" id="16_e" impl="CODSTA-MCPP-16_e" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_e.rule"/>
            </rule>
            <rule header="Never return lambdas that capture local objects by reference" id="17" impl="CODSTA-MCPP-17" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-17.rule"/>
            </rule>
            <rule header="Never capture local objects from an outer lambda by reference" id="17_b" impl="CODSTA-MCPP-17_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-17_b.rule"/>
            </rule>
            <rule header="The lambda that captures local objects by reference should not be assigned to the variable with a greater lifetime" id="17_c" impl="CODSTA-MCPP-17_c" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-17_c.rule"/>
            </rule>
            <rule header="Avoid unnecessary default capture modes in lambda expressions" id="18_a" impl="CODSTA-MCPP-18_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-18_a.rule"/>
            </rule>
            <rule header="Avoid unnecessary lambda captures" id="18_b" impl="CODSTA-MCPP-18_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-18_b.rule"/>
            </rule>
            <rule header="Declare assignment operators with the ref-qualifier &amp;" id="19" impl="CODSTA-MCPP-19" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-19.rule"/>
            </rule>
            <rule header="Prefer smart pointers over raw local pointers" id="20" impl="CODSTA-MCPP-20" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-20.rule"/>
            </rule>
            <rule header="Do not call lock() directly on a mutex" id="21" impl="CODSTA-MCPP-21" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-21.rule"/>
            </rule>
            <rule header="Use explicit ref-qualifiers on auto declarations in range-based 'for' loops" id="22" impl="CODSTA-MCPP-22" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-22.rule"/>
            </rule>
            <rule header="If a public destructor of a class is non-virtual, then the class should be declared final" id="23" impl="CODSTA-MCPP-23" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-23.rule"/>
            </rule>
            <rule header="Only one of virtual, override or final should be specified in a member function declaration" id="24" impl="CODSTA-MCPP-24" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-24.rule"/>
            </rule>
            <rule header="Digit sequences separators ' shall only be used consistently" id="25" impl="CODSTA-MCPP-25" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-25.rule"/>
            </rule>
            <rule header="A pointer to member virtual function shall only be tested for equality with null-pointer-constant" id="26" impl="CODSTA-MCPP-26" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-26.rule"/>
            </rule>
            <rule header="All std::hash specializations for user-defined types shall have a noexcept function call operator" id="27" impl="CODSTA-MCPP-27" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-27.rule"/>
            </rule>
            <rule header="A lambda shall not be an operand to typeid" id="28" impl="CODSTA-MCPP-28" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-28.rule"/>
            </rule>
            <rule header="Use smart pointers when passing a pointer to an object in a thread" id="29" impl="CODSTA-MCPP-29" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-29.rule"/>
            </rule>
            <rule header="Consider using 'std::unique_ptr' instead of 'std::shared_ptr' for local objects" id="30" impl="CODSTA-MCPP-30" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-30.rule"/>
            </rule>
            <rule header="Define both sized and unsized versions of operator delete" id="31" impl="CODSTA-MCPP-31" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-31.rule"/>
            </rule>
            <rule header="User defined literals operators shall only perform conversion of passed parameters" id="33" impl="CODSTA-MCPP-33" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-33.rule"/>
            </rule>
            <rule header="A smart pointer shall only be used as a parameter type if it expresses lifetime semantics" id="34" impl="CODSTA-MCPP-34" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-34.rule"/>
            </rule>
            <rule header="A parameter should only be declared as a non-const lvalue reference to 'std::shared_ptr' or 'std::unique_ptr' if the function replaces the managed object" id="35" impl="CODSTA-MCPP-35" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-35.rule"/>
            </rule>
            <rule header="Do not declare the type of a parameter as an rvalue reference to 'std::shared_ptr' or 'std::unique_ptr'" id="36" impl="CODSTA-MCPP-36" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-36.rule"/>
            </rule>
         </category>
      </category>
      <category description="Comments" name="COMMENT">
         <rule header="Prefer C++ style comment" id="01" impl="COMMENT-01" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-01.rule"/>
         </rule>
         <rule header="Provide copyright information" id="02" impl="COMMENT-02" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-02.rule"/>
         </rule>
         <rule header="Every source file will be documented with an introductory comment that provides information on the file" id="03" impl="COMMENT-03" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-03.rule"/>
         </rule>
         <rule header="Comment every function" id="04" impl="COMMENT-04" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-04.rule"/>
         </rule>
         <rule header="Each variable declaration should be commented" id="05" impl="COMMENT-05" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-05.rule"/>
         </rule>
         <rule header="Each typedef should be commented" id="06" impl="COMMENT-06" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-06.rule"/>
         </rule>
         <rule header="Each enumeration value should be commented" id="07" impl="COMMENT-07" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-07.rule"/>
         </rule>
         <rule header="Each structure member variable should be commented" id="08" impl="COMMENT-08" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-08.rule"/>
         </rule>
         <rule header="All usage of assembler shall be documented" id="09" impl="COMMENT-09" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-09.rule"/>
         </rule>
         <rule header="Use of floating-point arithmetic shall be documented" id="10" impl="COMMENT-10" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-10.rule"/>
         </rule>
         <rule header="The character sequence // shall not be used within a C-style comment" id="11" impl="COMMENT-11" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-11.rule"/>
         </rule>
         <rule header="The character sequence /* shall not be used within a C++-style comment" id="12" impl="COMMENT-12" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-12.rule"/>
         </rule>
         <rule header="Line-splicing shall not be used in // comments" id="13" impl="COMMENT-13" quickfix="false" scope="line" severity="2">
            <file path="COMMENT\COMMENT-13.rule"/>
         </rule>
      </category>
      <category description="Exceptions" name="EXCEPT">
         <rule header="Never allow an exception to be thrown from a destructor, deallocation, and swap" id="01" impl="EXCEPT-01" quickfix="false" scope="line" severity="1">
            <file path="EXCEPT\EXCEPT-01.rule"/>
         </rule>
         <rule header="Throw by value, catch by reference" id="02" impl="EXCEPT-02" quickfix="false" scope="line" severity="1">
            <file path="EXCEPT\EXCEPT-02.rule"/>
         </rule>
         <rule header="Do not throw from within destructor" id="03" impl="EXCEPT-03" quickfix="false" scope="line" severity="1">
            <file path="EXCEPT\EXCEPT-03.rule"/>
         </rule>
         <rule header="All exceptions should be rethrown or logged with standard logger" id="04" impl="EXCEPT-04" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-04.rule"/>
         </rule>
         <rule header="C++ exceptions shall not be used (i.e. throw, catch and try shall not be used.)" id="05" impl="EXCEPT-05" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-05.rule"/>
         </rule>
         <rule header="There should be at least one exception handler to catch all otherwise unhandled exceptions" id="06" impl="EXCEPT-06" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-06.rule"/>
         </rule>
         <rule header="An empty throw (throw;) shall only be used in the compound-statement of a catch handler" id="07" impl="EXCEPT-07" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-07.rule"/>
         </rule>
         <rule header="Exceptions shall be raised only after start-up and before termination of the program" id="08" impl="EXCEPT-08" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-08.rule"/>
         </rule>
         <rule header="An exception object should not have pointer type" id="09" impl="EXCEPT-09" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-09.rule"/>
         </rule>
         <rule header="Control shall not be transferred into a try or catch block using a goto or a switch statement" id="10" impl="EXCEPT-10" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-10.rule"/>
         </rule>
         <rule header="The assignment-expression of a throw statement shall not itself cause an exception to be thrown" id="11" impl="EXCEPT-11" quickfix="false" scope="line" severity="1">
            <file path="EXCEPT\EXCEPT-11.rule"/>
         </rule>
         <rule header="NULL shall not be thrown explicitly" id="12" impl="EXCEPT-12" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-12.rule"/>
         </rule>
         <rule header="Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point" id="13" impl="EXCEPT-13" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-13.rule"/>
         </rule>
         <rule header="Where a function's declaration includes an exception-specification, the function shall only be capable of throwing exceptions of the indicated type(s)" id="14" impl="EXCEPT-14" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-14.rule"/>
         </rule>
         <rule header="A class type exception shall always be caught by reference" id="15" impl="EXCEPT-15" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-15.rule"/>
         </rule>
         <rule header="Handlers of a function-try-block implementation of a class constructor or destructor shall not reference nonstatic members from this class or its bases" id="16" impl="EXCEPT-16" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-16.rule"/>
         </rule>
         <rule header="Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class" id="17" impl="EXCEPT-17" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-17.rule"/>
         </rule>
         <rule header="Function called in global or namespace scope shall not throw unhandled exceptions" id="18" impl="EXCEPT-18" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-18.rule"/>
         </rule>
         <rule header="Exception objects must be nothrow copy constructible" id="19" impl="EXCEPT-19" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-19.rule"/>
         </rule>
         <rule header="An explicitly declared copy constructor for a class that inherits from 'std::exception' should have a non-throwing exception specification" id="20" impl="EXCEPT-20" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-20.rule"/>
         </rule>
         <rule header="All user-provided move constructors and move assignment operators shall not exit with an exception" id="21" impl="EXCEPT-21" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-21.rule"/>
         </rule>
      </category>
      <category description="Formatting" name="FORMAT">
         <rule header="Tabs that do not use ASCII spaces shall not be used" id="01" impl="FORMAT-01" quickfix="false" scope="line" severity="5">
            <file path="FORMAT\FORMAT-01.rule"/>
         </rule>
         <rule header="Place an opening brace '{' on its own line" id="02" impl="FORMAT-02" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-02.rule"/>
         </rule>
         <rule header="Place a closing brace '}' on its own line" id="03" impl="FORMAT-03" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-03.rule"/>
         </rule>
         <rule header="Physical lines should be less than eighty characters" id="04" impl="FORMAT-04" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-04.rule"/>
         </rule>
         <rule header="The length of a macro should not exceed 10 lines" id="05" impl="FORMAT-05" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-05.rule"/>
         </rule>
         <rule header="Only one statement shall be allowed per line" id="06" impl="FORMAT-06" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-06.rule"/>
         </rule>
         <rule header="There shall be a single ASCII space character preceding assignment operators" id="07" impl="FORMAT-07" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-07.rule"/>
         </rule>
         <rule header="There shall be a single ASCII space character following assignment operators" id="08" impl="FORMAT-08" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-08.rule"/>
         </rule>
         <rule header="There shall be a single ASCII space character preceding bitwise operators" id="09" impl="FORMAT-09" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-09.rule"/>
         </rule>
         <rule header="There shall be a single ASCII space character following bitwise operators" id="10" impl="FORMAT-10" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-10.rule"/>
         </rule>
         <rule header="There shall be a single ASCII space character preceding and following bitwise operator '&amp;'" id="11" impl="FORMAT-11" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-11.rule"/>
         </rule>
         <rule header="There shall be a single ASCII space character between a conditional statement keyword and its opening parenthesis" id="12" impl="FORMAT-12" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-12.rule"/>
         </rule>
         <rule header="There shall be a maximum of 1 ASCII space character following the opening parenthesis in conditional statements" id="13" impl="FORMAT-13" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-13.rule"/>
         </rule>
         <rule header="There shall be a single ASCII space character preceding ternary conditional operator" id="14" impl="FORMAT-14" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-14.rule"/>
         </rule>
         <rule header="There shall be a single ASCII space character following ternary conditional operator" id="15" impl="FORMAT-15" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-15.rule"/>
         </rule>
         <rule header="There shall be a single ASCII space character preceding and following relational and equality operators" id="16" impl="FORMAT-16" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-16.rule"/>
         </rule>
         <rule header="There shall be no white space following '.' or '-&gt;' operator" id="17" impl="FORMAT-17" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-17.rule"/>
         </rule>
         <rule header="There shall be no white space preceding '.' or '-&gt;' operator" id="18" impl="FORMAT-18" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-18.rule"/>
         </rule>
         <rule header="There shall be a single ASCII space character following all commas" id="19" impl="FORMAT-19" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-19.rule"/>
         </rule>
         <rule header="There shall be a single ASCII space character following all semicolons" id="20" impl="FORMAT-20" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-20.rule"/>
         </rule>
         <rule header="There should be no space between a unary operator &quot;!&quot; or &quot;~&quot; and its operand" id="21" impl="FORMAT-21" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-21.rule"/>
         </rule>
         <rule header="There should be no space between a increment/decrement operator (++/--) and its operand" id="22" impl="FORMAT-22" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-22.rule"/>
         </rule>
         <rule header="There shall be no white spaces between the &quot;return&quot; or  &quot;sizeof &quot; statements  and its opening parenthesis" id="23" impl="FORMAT-23" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-23.rule"/>
         </rule>
         <rule header="There shall be no white spaces surrounding &quot;return&quot; or  &quot;sizeof &quot; statements argument or expression" id="24" impl="FORMAT-24" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-24.rule"/>
         </rule>
         <rule header="Parenthesis shall be used with the &quot;sizeof&quot; statement" id="25" impl="FORMAT-25" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-25.rule"/>
         </rule>
         <rule header="Parenthesis shall be used with the &quot;return&quot; statement" id="25_b" impl="FORMAT-25_b" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-25_b.rule"/>
         </rule>
         <rule header="There shall be a single ASCII space character preceding and following logical operators" id="26" impl="FORMAT-26" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-26.rule"/>
         </rule>
         <rule header="Line should be indented by a multiple of four spaces" id="27" impl="FORMAT-27" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-27.rule"/>
         </rule>
         <rule header="In a function definition, the return type of the function should be written on a separate line directly above the function name" id="28" impl="FORMAT-28" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-28.rule"/>
         </rule>
         <rule header="Multiple variable declarations shall not be allowed on the same line" id="29" impl="FORMAT-29" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-29.rule"/>
         </rule>
         <rule header="Place left parenthesis directly after function name" id="30" impl="FORMAT-30" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-30.rule"/>
         </rule>
         <rule header="Separate logical tests in conditional expressions" id="31" impl="FORMAT-31" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-31.rule"/>
         </rule>
         <rule header="The dereference operator '*' and the address-of operator '&amp;' should be directly connected with the type" id="32" impl="FORMAT-32" quickfix="false" scope="line" severity="4">
            <file path="FORMAT\FORMAT-32.rule"/>
         </rule>
         <rule header="Each variable should be declared in a separate declaration statement" id="33" impl="FORMAT-33" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-33.rule"/>
         </rule>
         <rule header="Braces &quot;{}&quot; which enclose a block should be placed in the same column" id="34" impl="FORMAT-34" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-34.rule"/>
         </rule>
         <rule header="When declaring functions, the leading parenthesis and the first argument are to be written on the same line as the function name" id="35" impl="FORMAT-35" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-35.rule"/>
         </rule>
         <rule header="Sibling statement lines should be indented to the same level" id="36" impl="FORMAT-36" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-36.rule"/>
         </rule>
         <rule header="First line in control statement body should be indented more than control statement keyword" id="37" impl="FORMAT-37" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-37.rule"/>
         </rule>
         <rule header="When declaring functions with more than 2 parameters, the leading parenthesis and the first argument are to be written on the same line as the function name, each additional argument will be written on a separate line" id="38" impl="FORMAT-38" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-38.rule"/>
         </rule>
         <rule header="Sort #include directives in alphabetical order" id="39" impl="FORMAT-39" quickfix="false" scope="line" severity="4">
            <file path="FORMAT\FORMAT-39.rule"/>
         </rule>
         <rule header="White spaces after the opening square bracket '[' and before its closing square bracket ']' shall be used in consistent way" id="40" impl="FORMAT-40" quickfix="false" scope="line" severity="5">
            <file path="FORMAT\FORMAT-40.rule"/>
         </rule>
         <rule header="There shall be no space between '[' opening square bracket and preceding token" id="41" impl="FORMAT-41" quickfix="false" scope="line" severity="5">
            <file path="FORMAT\FORMAT-41.rule"/>
         </rule>
         <rule header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" id="42" impl="FORMAT-42" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-42.rule"/>
         </rule>
         <rule header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" id="43" impl="FORMAT-43" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-43.rule"/>
         </rule>
         <rule header="Braces (&quot;{}&quot;) which enclose a block will not have an empty line after &quot;{&quot; nor before &quot;}&quot;" id="44" impl="FORMAT-44" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-44.rule"/>
         </rule>
         <rule header="There should be no space between a unary operator &quot;&amp;&quot;, &quot;*&quot;, &quot;+&quot;, &quot;-&quot; and its operand" id="45" impl="FORMAT-45" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-45.rule"/>
         </rule>
         <rule header="There should be no space between an increment/decrement operator (++/--) and its operand in macro definition" id="46" impl="FORMAT-46" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-46.rule"/>
         </rule>
      </category>
      <category description="High Integrity C++" name="HICPP">
         <category name="12_4_3">
            <rule header="Do not specify both an NSDMI and a member initializer in a constructor for the same non-static member" id="a" impl="HICPP-12_4_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-12_4_3-a.rule"/>
            </rule>
         </category>
         <category name="12_4_5">
            <rule header="Use delegating constructors to reduce code duplication" id="a" impl="HICPP-12_4_5-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-12_4_5-a.rule"/>
            </rule>
         </category>
         <category name="12_5_1">
            <rule header="Explicitly define =default or =delete special member functions of concrete classes implicitly provided by the compiler" id="a" impl="HICPP-12_5_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-12_5_1-a.rule"/>
            </rule>
         </category>
         <category name="12_5_2">
            <rule header="Define special members =default if the behavior is equivalent" id="a" impl="HICPP-12_5_2-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-12_5_2-a.rule"/>
            </rule>
         </category>
         <category name="13_2_3">
            <rule header="Declare binary arithmetic and bitwise operators as non-members" id="a" impl="HICPP-13_2_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-13_2_3-a.rule"/>
            </rule>
         </category>
         <category name="13_2_4">
            <rule header="When overloading the subscript operator (operator[]), implement both const and non-const versions" id="a" impl="HICPP-13_2_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-13_2_4-a.rule"/>
            </rule>
         </category>
         <category name="15_1_1">
            <rule header="Only use instances of std::exception for exceptions" id="a" impl="HICPP-15_1_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-15_1_1-a.rule"/>
            </rule>
         </category>
         <category name="16_1_4">
            <rule header="Use &lt;&gt; brackets for system and standard library headers. Use quotes for all other headers" id="a" impl="HICPP-16_1_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-16_1_4-a.rule"/>
            </rule>
         </category>
         <category name="17_2_1">
            <rule header="Wrap use of the C Standard Library" id="a" impl="HICPP-17_2_1-a" quickfix="false" scope="line" severity="4">
               <file path="HICPP\HICPP-17_2_1-a.rule"/>
            </rule>
         </category>
         <category name="17_3_1">
            <rule header="Do not use std::move on objects declared with the const or const &amp; type" id="a" impl="HICPP-17_3_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-17_3_1-a.rule"/>
            </rule>
         </category>
         <category name="17_3_2">
            <rule header="Use std::forward to forward universal references" id="a" impl="HICPP-17_3_2-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-17_3_2-a.rule"/>
            </rule>
         </category>
         <category name="17_3_4">
            <rule header="Do not create smart pointers of array type" id="a" impl="HICPP-17_3_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-17_3_4-a.rule"/>
            </rule>
         </category>
         <category name="17_3_5">
            <rule header="Do not create an rvalue reference of std::array" id="a" impl="HICPP-17_3_5-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-17_3_5-a.rule"/>
            </rule>
            <rule header="Do not create an rvalue reference of std::array" id="b" impl="HICPP-17_3_5-b" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-17_3_5-b.rule"/>
            </rule>
         </category>
         <category name="17_4_1">
            <rule header="Use const container calls when the result is immediately converted to a const iterator" id="a" impl="HICPP-17_4_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-17_4_1-a.rule"/>
            </rule>
         </category>
         <category name="18_1_1">
            <rule header="Do not use platform-specific multi-threading facilities" id="a" impl="HICPP-18_1_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_1_1-a.rule"/>
            </rule>
         </category>
         <category name="18_2_1">
            <rule header="Use high_integrity::thread in place of std::thread" id="a" impl="HICPP-18_2_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_2_1-a.rule"/>
            </rule>
         </category>
         <category name="18_2_3">
            <rule header="Do not share volatile data between threads" id="a" impl="HICPP-18_2_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_2_3-a.rule"/>
            </rule>
         </category>
         <category name="18_2_4">
            <rule header="Use std::call_once rather than the Double-Checked Locking pattern" id="a" impl="HICPP-18_2_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_2_4-a.rule"/>
            </rule>
         </category>
         <category name="18_3_3">
            <rule header="Do not use std::recursive_mutex" id="a" impl="HICPP-18_3_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_3_3-a.rule"/>
            </rule>
         </category>
         <category name="18_3_4">
            <rule header="Only use std::unique lock when std::lock guard cannot be used" id="a" impl="HICPP-18_3_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_3_4-a.rule"/>
            </rule>
         </category>
         <category name="18_3_5">
            <rule header="Do not access the members of std::mutex directly" id="a" impl="HICPP-18_3_5-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_3_5-a.rule"/>
            </rule>
         </category>
         <category name="18_3_6">
            <rule header="Do not use relaxed atomics" id="a" impl="HICPP-18_3_6-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_3_6-a.rule"/>
            </rule>
         </category>
         <category name="18_4_1">
            <rule header="Do not use std::condition_variable_any on a std::mutex" id="a" impl="HICPP-18_4_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_4_1-a.rule"/>
            </rule>
         </category>
         <category name="1_3_4">
            <rule header="Do not use deprecated STL library features" id="a" impl="HICPP-1_3_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-1_3_4-a.rule"/>
            </rule>
         </category>
         <category name="1_3_5">
            <rule header="Do not use throw exception specifications" id="a" impl="HICPP-1_3_5-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-1_3_5-a.rule"/>
            </rule>
         </category>
         <category name="2_3_2">
            <rule header="Do not use comments to remove sections of code" id="a" impl="HICPP-2_3_2-a" quickfix="false" scope="line" severity="4">
               <file path="HICPP\HICPP-2_3_2-a.rule"/>
            </rule>
         </category>
         <category name="3_3_1">
            <rule header="Do not use variables with static storage duration" id="a" impl="HICPP-3_3_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-3_3_1-a.rule"/>
            </rule>
         </category>
         <category name="4_2_1">
            <rule header="Apply the U suffix to literals used in a context that requires an unsigned integral expression" id="a" impl="HICPP-4_2_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-4_2_1-a.rule"/>
            </rule>
         </category>
         <category name="5_1_4">
            <rule header="Do not capture variables implicitly in a lambda" id="a" impl="HICPP-5_1_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-5_1_4-a.rule"/>
            </rule>
         </category>
         <category name="5_1_5">
            <rule header="Include a parameter list in every lambda expression" id="a" impl="HICPP-5_1_5-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-5_1_5-a.rule"/>
            </rule>
         </category>
         <category name="5_4_2">
            <rule header="Do not cast an expression to an enumeration type" id="a" impl="HICPP-5_4_2-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-5_4_2-a.rule"/>
            </rule>
         </category>
         <category name="5_8_1">
            <rule header="Do not use the conditional operator (?:) as a sub-expression" id="a" impl="HICPP-5_8_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-5_8_1-a.rule"/>
            </rule>
         </category>
         <category name="6_2_1">
            <rule header="Implement a loop that only uses element values as a range-based loop" id="a" impl="HICPP-6_2_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-6_2_1-a.rule"/>
            </rule>
         </category>
         <category name="7_1_10">
            <rule header="Use static_assert for assertions involving compile time constants" id="a" impl="HICPP-7_1_10-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_10-a.rule"/>
            </rule>
         </category>
         <category name="7_1_3">
            <rule header="Do not place type specifiers before non-type specifiers in a declaration" id="a" impl="HICPP-7_1_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_3-a.rule"/>
            </rule>
         </category>
         <category name="7_1_4">
            <rule header="Place CV-qualifiers on the right hand side of the type they apply to" id="a" impl="HICPP-7_1_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_4-a.rule"/>
            </rule>
         </category>
         <category name="7_1_5">
            <rule header="Do not inline large functions" id="a" impl="HICPP-7_1_5-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_5-a.rule"/>
            </rule>
         </category>
         <category name="7_1_6">
            <rule header="Use class types or typedefs to abstract scalar quantities and standard integer types" id="b" impl="HICPP-7_1_6-b" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_6-b.rule"/>
            </rule>
            <rule header="Use class types or typedefs to abstract scalar quantities and standard integer types" id="c" impl="HICPP-7_1_6-c" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_6-c.rule"/>
            </rule>
         </category>
         <category name="7_1_7">
            <rule header="Use trailing return types when possible instead of specifying type using typename" id="a" impl="HICPP-7_1_7-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_7-a.rule"/>
            </rule>
         </category>
         <category name="7_1_8">
            <rule header="Use auto id = expr when declaring a variable that is the same type as the initializer function call" id="a" impl="HICPP-7_1_8-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_8-a.rule"/>
            </rule>
         </category>
         <category name="7_1_9">
            <rule header="Do not explicitly specify the return type of a lambda" id="a" impl="HICPP-7_1_9-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_9-a.rule"/>
            </rule>
         </category>
         <category name="7_2_1">
            <rule header="Use an explicit enumeration base and ensure that it is large enough to store all enumerators" id="a" impl="HICPP-7_2_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_2_1-a.rule"/>
            </rule>
         </category>
         <category name="7_2_2">
            <rule header="Initialize all, only the first, or none of the enumerators in an enumeration" id="a" impl="HICPP-7_2_2-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_2_2-a.rule"/>
            </rule>
         </category>
         <category name="7_5_1">
            <rule header="Do not use the asm declaration" id="a" impl="HICPP-7_5_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_5_1-a.rule"/>
            </rule>
         </category>
         <category name="8_2_3">
            <rule header="Pass small objects with a trivial copy constructor by value" id="a" impl="HICPP-8_2_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-8_2_3-a.rule"/>
            </rule>
            <rule header="Pass small objects with a trivial copy constructor by value" id="b" impl="HICPP-8_2_3-b" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-8_2_3-b.rule"/>
            </rule>
         </category>
         <category name="8_2_4">
            <rule header="Do not pass std::unique_ptr by const reference" id="a" impl="HICPP-8_2_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-8_2_4-a.rule"/>
            </rule>
         </category>
         <category name="8_3_3">
            <rule header="Do not use default arguments" id="a" impl="HICPP-8_3_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-8_3_3-a.rule"/>
            </rule>
         </category>
         <category name="8_3_4">
            <rule header="Define rvalue reference functions that have a const parameter as =delete" id="a" impl="HICPP-8_3_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-8_3_4-a.rule"/>
            </rule>
         </category>
         <category name="9_1_5">
            <rule header="Do not introduce virtual functions in a final class" id="a" impl="HICPP-9_1_5-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-9_1_5-a.rule"/>
            </rule>
         </category>
      </category>
      <category description="Initialization" name="INIT">
         <rule header="Objects with external linkage should not be initialized in a header file" id="01" impl="INIT-01" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-01.rule"/>
         </rule>
         <rule header="Do not initialize unsigned integer variables with signed constants" id="02" impl="INIT-02" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-02.rule"/>
         </rule>
         <rule header="Initialize all variables" id="03" impl="INIT-03" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-03.rule"/>
         </rule>
         <rule header="Initialize all pointer variables" id="04" impl="INIT-04" quickfix="false" scope="line" severity="2">
            <file path="INIT\INIT-04.rule"/>
         </rule>
         <rule header="Do not initialize a reference to an object whose address can be changed" id="05" impl="INIT-05" quickfix="false" scope="line" severity="1">
            <file path="INIT\INIT-05.rule"/>
         </rule>
         <rule header="All member variables should be initialized in constructor" id="06" impl="INIT-06" quickfix="false" scope="line" severity="1">
            <file path="INIT\INIT-06.rule"/>
         </rule>
         <rule header="Make class members' initialization explicit by providing user-defined constructor" id="07" impl="INIT-07" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-07.rule"/>
         </rule>
         <rule header="User-defined constructor must be provided to ensure the proper initialization of dynamically allocated class objects" id="08" impl="INIT-08" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-08.rule"/>
         </rule>
         <rule header="Initialize static class members" id="09" impl="INIT-09" quickfix="false" scope="line" severity="1">
            <file path="INIT\INIT-09.rule"/>
         </rule>
         <rule header="List members in an initialization list in the order in which they are declared" id="10" impl="INIT-10" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-10.rule"/>
         </rule>
         <rule header="An assignment operator shall assign all data members" id="11" impl="INIT-11" quickfix="false" scope="line" severity="2">
            <file path="INIT\INIT-11.rule"/>
         </rule>
         <rule header="Avoid initialization order problems across translation units by replacing non-local static objects with local static objects" id="12" impl="INIT-12" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-12.rule"/>
         </rule>
         <rule header="Do not assume that members are initialized in any special order in constructors" id="13" impl="INIT-13" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-13.rule"/>
         </rule>
         <rule header="Do not use uninitialized nonstatic member variables in base class constructors" id="13_a" impl="INIT-13_a" quickfix="false" scope="line" severity="1">
            <file path="INIT\INIT-13_a.rule"/>
         </rule>
         <rule header="Do not use uninitialized nonstatic member variables of nonvirtual base classes in virtual base class constructors" id="13_b" impl="INIT-13_b" quickfix="false" scope="line" severity="1">
            <file path="INIT\INIT-13_b.rule"/>
         </rule>
         <rule header="Do not use possibly uninitialized nonstatic member variables of base classes in base class constructors" id="13_c" impl="INIT-13_c" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-13_c.rule"/>
         </rule>
         <rule header="Prefer initialization to assignment in constructors" id="14" impl="INIT-14" quickfix="false" scope="line" severity="5">
            <file path="INIT\INIT-14.rule"/>
         </rule>
         <rule header="Consider adding constructor to initialize 'struct' member variables" id="15" impl="INIT-15" quickfix="false" scope="line" severity="4">
            <file path="INIT\INIT-15.rule"/>
         </rule>
         <rule header="The initializer for an aggregate or union shall be enclosed in braces" id="16" impl="INIT-16" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-16.rule"/>
         </rule>
      </category>
      <category description="Metrics" name="METRICS">
         <rule header="Avoid functions with over 50 lines" id="01" impl="METRICS-01" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-01.rule"/>
         </rule>
         <rule header="Avoid switch statements with many cases" id="02" impl="METRICS-02" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-02.rule"/>
         </rule>
         <rule header="Number of blocks of code in a function" id="03" impl="METRICS-03" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-03.rule"/>
         </rule>
         <rule header="Number of function calls within function" id="04" impl="METRICS-04" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-04.rule"/>
         </rule>
         <rule header="Class inheritance level" id="05" impl="METRICS-05" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-05.rule"/>
         </rule>
         <rule header="Number of data member(s) per class should not exceed 15" id="06" impl="METRICS-06" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-06.rule"/>
         </rule>
         <rule header="Number of methods per class" id="07" impl="METRICS-07" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-07.rule"/>
         </rule>
         <rule header="Number of parameter(s) per method should not exceed 10" id="08" impl="METRICS-08" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-08.rule"/>
         </rule>
         <rule header="Number of private data member(s) per class" id="09" impl="METRICS-09" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-09.rule"/>
         </rule>
         <rule header="Number of private methods per class" id="10" impl="METRICS-10" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-10.rule"/>
         </rule>
         <rule header="Number of protected data member(s) per class" id="11" impl="METRICS-11" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-11.rule"/>
         </rule>
         <rule header="Number of protected methods per class" id="12" impl="METRICS-12" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-12.rule"/>
         </rule>
         <rule header="Number of public data member(s) per class" id="13" impl="METRICS-13" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-13.rule"/>
         </rule>
         <rule header="Number of public methods per class" id="14" impl="METRICS-14" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-14.rule"/>
         </rule>
         <rule header="Avoid functions with more than 5 parameters" id="15" impl="METRICS-15" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-15.rule"/>
         </rule>
         <rule header="Macros should not use more than 5 parameters" id="16" impl="METRICS-16" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-16.rule"/>
         </rule>
         <rule header="Avoid structs, unions, or classes with more than 20 fields" id="17" impl="METRICS-17" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-17.rule"/>
         </rule>
         <rule header="Follow the Cyclomatic Complexity limit of 10" id="18" impl="METRICS-18" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-18.rule"/>
         </rule>
         <rule header="The percentage of comment lines versus the total number of module lines should be between 20 and 60" id="19" impl="METRICS-19" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-19.rule"/>
         </rule>
         <rule header="Avoid too long functions (declarations and statements)" id="20" impl="METRICS-20" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-20.rule"/>
         </rule>
         <rule header="Avoid too long functions (blocks)" id="21" impl="METRICS-21" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-21.rule"/>
         </rule>
         <rule header="Avoid functions with over 75 lines of code" id="22" impl="METRICS-22" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-22.rule"/>
         </rule>
         <rule header="Nested block depth should not be higher than 5" id="23" impl="METRICS-23" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-23.rule"/>
         </rule>
         <rule header="Avoid source files that are longer than 500 lines" id="24" impl="METRICS-24" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-24.rule"/>
         </rule>
         <rule header="Any one function (or method) will contain no more than 200 logical source lines of code (L-SLOCs)" id="25" impl="METRICS-25" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-25.rule"/>
         </rule>
         <rule header="Source lines will be kept to a length of 120 characters or less" id="26" impl="METRICS-26" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-26.rule"/>
         </rule>
         <rule header="Functions with more than 7 parameters will not be used" id="27" impl="METRICS-27" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-27.rule"/>
         </rule>
         <rule header="Follow the Cyclomatic Complexity limit of 20" id="28" impl="METRICS-28" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-28.rule"/>
         </rule>
         <rule header="Report Cyclomatic Complexity" id="29" impl="METRICS-29" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-29.rule"/>
         </rule>
         <rule header="No function should be longer than 60 lines of code" id="30" impl="METRICS-30" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-30.rule"/>
         </rule>
         <rule header="The assertion density of the code should average to a minimum of two assertions per function" id="31" impl="METRICS-31" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-31.rule"/>
         </rule>
         <rule header="All functions with more than 20 lines should contain at least 2 assertions" id="32" impl="METRICS-32" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-32.rule"/>
         </rule>
         <rule header="Report Essential Complexity" id="33" impl="METRICS-33" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-33.rule"/>
         </rule>
         <rule header="Follow the Essential Complexity limit of 4" id="34" impl="METRICS-34" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-34.rule"/>
         </rule>
         <rule header="Follow the Essential Complexity limit of 10" id="35" impl="METRICS-35" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-35.rule"/>
         </rule>
         <rule header="A function should not be called from more than 5 different functions" id="36" impl="METRICS-36" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-36.rule"/>
         </rule>
         <rule header="A function should not call more than 7 different functions" id="37" impl="METRICS-37" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-37.rule"/>
         </rule>
         <rule header="The number of statements within function should be in range 1 - 50" id="38" impl="METRICS-38" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-38.rule"/>
         </rule>
         <rule header="The value of VOCF metric for a function should not be higher than 4" id="39" impl="METRICS-39" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-39.rule"/>
         </rule>
         <rule header="Statements within function should not be nested deeper than 4 levels" id="40" impl="METRICS-40" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-40.rule"/>
         </rule>
         <rule header="The number of blocks of comments before and inside function to the number of statements in function should be &gt; 0.2" id="41" impl="METRICS-41" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-41.rule"/>
         </rule>
         <rule header="Follow the Essential Complexity limit of 1" id="42" impl="METRICS-42" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-42.rule"/>
         </rule>
         <rule header="Report the value of Halstead's delivered bugs (B) for a function" id="43" impl="METRICS-43" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-43.rule"/>
         </rule>
      </category>
      <category description="MISRA C 1998" name="MISRA">
         <rule header="Provisions should be made for appropriate run-time checking" id="004_a" impl="MISRA-004_a" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-004_a.rule"/>
         </rule>
         <rule header="Provisions should be made for appropriate run-time checking" id="004_b" impl="MISRA-004_b" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-004_b.rule"/>
         </rule>
         <rule header="Only use characters defined in ISO C standard" id="005" impl="MISRA-005" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-005.rule"/>
         </rule>
         <rule header="Values of character types shall be restricted to a defined and documented subset of ISO 10646-1" id="006" impl="MISRA-006" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-006.rule"/>
         </rule>
         <rule header="Do not use wide string literals" id="008" impl="MISRA-008" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-008.rule"/>
         </rule>
         <rule header="The basic types of char, int, short, long, float and double should not be used, but specific-length equivalents should be typedef'd" id="013" impl="MISRA-013" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-013.rule"/>
         </rule>
         <rule header="Explicitly declare 'char' type as signed or unsigned" id="014" impl="MISRA-014" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-014.rule"/>
         </rule>
         <rule header="The underlying bit representations of floating point numbers shall not be used" id="016" impl="MISRA-016" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-016.rule"/>
         </rule>
         <rule header="Use type suffix for numeric constants" id="018_a" impl="MISRA-018_a" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-018_a.rule"/>
         </rule>
         <rule header="Use type suffix for numeric constants" id="018_b" impl="MISRA-018_b" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-018_b.rule"/>
         </rule>
         <rule header="Use type suffix for numeric constants" id="018_c" impl="MISRA-018_c" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-018_c.rule"/>
         </rule>
         <rule header="Use type suffix for numeric constants" id="018_d" impl="MISRA-018_d" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-018_d.rule"/>
         </rule>
         <rule header="All functions shall be declared before use" id="020" impl="MISRA-020" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-020.rule"/>
         </rule>
         <rule header="Declare objects at function scope" id="022" impl="MISRA-022" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-022.rule"/>
         </rule>
         <rule header="Objects or functions with external linkage shall be declared in a header file" id="023" impl="MISRA-023" quickfix="false" scope="line" severity="4">
            <file path="MISRA\MISRA-023.rule"/>
         </rule>
         <rule header="Identifiers shall not simultaneously have both internal and external linkage in the same translation unit" id="024" impl="MISRA-024" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-024.rule"/>
         </rule>
         <rule header="External object should not be declared in more than one file" id="027" impl="MISRA-027" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-027.rule"/>
         </rule>
         <rule header="External objects should not be declared in implementation files" id="027_b" impl="MISRA-027_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-027_b.rule"/>
         </rule>
         <rule header="The 'register' storage class specifier shall not be used" id="028" impl="MISRA-028" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-028.rule"/>
         </rule>
         <rule header="The use of a tag shall agree with its declaration" id="029" impl="MISRA-029" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-029.rule"/>
         </rule>
         <rule header="All automatic variables shall have been assigned a value before being used" id="030" impl="MISRA-030" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-030.rule"/>
         </rule>
         <rule header="Invalid range of the right hand operand of a shift operator" id="038" impl="MISRA-038" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-038.rule"/>
         </rule>
         <rule header="Document integer division" id="041" impl="MISRA-041" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-041.rule"/>
         </rule>
         <rule header="The comma operator shall not be used, except in the control expression of a for loop" id="042" impl="MISRA-042" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-042.rule"/>
         </rule>
         <rule header="Implicit conversions from wider to narrower integral type which may result in a loss of information shall not be used" id="043" impl="MISRA-043" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-043.rule"/>
         </rule>
         <rule header="Avoid mixing arithmetic of different precisions in the same expression" id="043_b" impl="MISRA-043_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-043_b.rule"/>
         </rule>
         <rule header="Implicit conversions from integral to floating type which may result in a loss of information shall not be used" id="043_c" impl="MISRA-043_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-043_c.rule"/>
         </rule>
         <rule header="Implicit conversions from integral constant to floating type which may result in a loss of information shall not be used" id="043_d" impl="MISRA-043_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-043_d.rule"/>
         </rule>
         <rule header="Do not use the volatile keyword" id="046_a" impl="MISRA-046_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-046_a.rule"/>
         </rule>
         <rule header="Assignment statements should not be nested within other assignment statements" id="046_b" impl="MISRA-046_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-046_b.rule"/>
         </rule>
         <rule header="Avoid possible integer overflow in expressions in which the result is cast to a wider integer type" id="048_a" impl="MISRA-048_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-048_a.rule"/>
         </rule>
         <rule header="Don't cast the dividend of two integers to a floating-point type" id="048_b" impl="MISRA-048_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-048_b.rule"/>
         </rule>
         <rule header="A null statement shall only occur on a line by itself, and shall not  have any other text on the same line" id="054" impl="MISRA-054" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-054.rule"/>
         </rule>
         <rule header="Do not use labels" id="055" impl="MISRA-055" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-055.rule"/>
         </rule>
         <rule header="Do not use the break statement" id="058" impl="MISRA-058" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-058.rule"/>
         </rule>
         <rule header="Do not use floating point variables as loop counters" id="065" impl="MISRA-065" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-065.rule"/>
         </rule>
         <rule header="Do not use functions with variable numbers of arguments" id="069" impl="MISRA-069" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-069.rule"/>
         </rule>
         <rule header="Functions shall have prototype declarations and the prototype shall be visible at both the function definition and call" id="071_a" impl="MISRA-071_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-071_a.rule"/>
         </rule>
         <rule header="Functions shall always have visible prototype at the function call" id="071_b" impl="MISRA-071_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-071_b.rule"/>
         </rule>
         <rule header="Provide none or all identifiers for function arguments" id="073" impl="MISRA-073" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-073.rule"/>
         </rule>
         <rule header="Provide expression for return statement of non-void functions" id="083" impl="MISRA-083" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-083.rule"/>
         </rule>
         <rule header="Avoid expressions in return statements of void functions" id="084" impl="MISRA-084" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-084.rule"/>
         </rule>
         <rule header="The #include directive shall be followed by either a &lt;filename&gt; or &quot;filename&quot; sequence" id="089" impl="MISRA-089" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-089.rule"/>
         </rule>
         <rule header="Enclose in parentheses whole definition of a function-like macro" id="096" impl="MISRA-096" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-096.rule"/>
         </rule>
         <rule header="Use only non-ambiguous forms of defined pre-processor operator" id="100" impl="MISRA-100" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-100.rule"/>
         </rule>
         <rule header="Pointer arithmetic should not be used" id="101" impl="MISRA-101" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-101.rule"/>
         </rule>
         <rule header="Do not use non-constant pointers to functions" id="104" impl="MISRA-104" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-104.rule"/>
         </rule>
         <rule header="All the functions pointed to by a single pointer to function shall be identical in the number and type of parameters and the return type" id="105" impl="MISRA-105" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-105.rule"/>
         </rule>
         <rule header="The NULL pointer shall not be dereferenced" id="107_a" impl="MISRA-107_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-107_a.rule"/>
         </rule>
         <rule header="The NULL pointer shall not be dereferenced" id="107_b" impl="MISRA-107_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-107_b.rule"/>
         </rule>
         <rule header="All members of structure or union should be fully specified" id="108" impl="MISRA-108" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-108.rule"/>
         </rule>
         <rule header="Unions shall not be used to access the sub-parts of larger data structure" id="110" impl="MISRA-110" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-110.rule"/>
         </rule>
         <rule header="All the members of a structure (or class/union) shall be named" id="113" impl="MISRA-113" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-113.rule"/>
         </rule>
         <rule header="Standard library function names shall not be reused" id="115" impl="MISRA-115" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-115.rule"/>
         </rule>
         <rule header="Do not use 'setlocale' function" id="121_a" impl="MISRA-121_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-121_a.rule"/>
         </rule>
         <rule header="Do not include &lt;locale.h&gt; header" id="121_b" impl="MISRA-121_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-121_b.rule"/>
         </rule>
      </category>
      <category description="MISRA C 2004" name="MISRA2004">
         <rule header="Avoid implicit conversions between signed and unsigned integer types" id="10_1_a" impl="MISRA2004-10_1_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_a.rule"/>
         </rule>
         <rule header="There shall be no implicit conversions from integral to floating type" id="10_1_b" impl="MISRA2004-10_1_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_b.rule"/>
         </rule>
         <rule header="Avoid implicit conversions of complex expressions" id="10_1_c" impl="MISRA2004-10_1_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_c.rule"/>
         </rule>
         <rule header="Avoid implicit conversions from wider to narrower types" id="10_1_d" impl="MISRA2004-10_1_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_d.rule"/>
         </rule>
         <rule header="Avoid implicit conversions of function return expressions" id="10_1_e" impl="MISRA2004-10_1_e" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_e.rule"/>
         </rule>
         <rule header="Avoid implicit conversions of complex expressions" id="10_1_f" impl="MISRA2004-10_1_f" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_f.rule"/>
         </rule>
         <rule header="Avoid implicit conversions of function arguments" id="10_1_g" impl="MISRA2004-10_1_g" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_g.rule"/>
         </rule>
         <rule header="Avoid implicit conversions between signed and unsigned integer types" id="10_1_h" impl="MISRA2004-10_1_h" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_h.rule"/>
         </rule>
         <rule header="Avoid implicit conversions of complex expressions" id="10_1_i" impl="MISRA2004-10_1_i" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_i.rule"/>
         </rule>
         <rule header="Avoid implicit conversions from floating to integral type" id="10_2_a" impl="MISRA2004-10_2_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_2_a.rule"/>
         </rule>
         <rule header="Avoid implicit conversions from wider to narrower floating type" id="10_2_b" impl="MISRA2004-10_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_2_b.rule"/>
         </rule>
         <rule header="Avoid implicit conversions from narrower to wider floating type" id="10_2_c" impl="MISRA2004-10_2_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_2_c.rule"/>
         </rule>
         <rule header="Avoid implicit conversions of floating point numbers from wider to narrower floating type" id="10_2_d" impl="MISRA2004-10_2_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_2_d.rule"/>
         </rule>
         <rule header="The value of a complex expression of integer type shall only be cast to a type  of the same signedness that is no wider than the underlying type of the expression" id="10_3" impl="MISRA2004-10_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_3.rule"/>
         </rule>
         <rule header="If the bitwise operators ~ and &lt;&lt; are applied to an operand of underlying type unsigned char or unsigned short, the result shall be immediately cast to the underlying type of the operand" id="10_5" impl="MISRA2004-10_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_5.rule"/>
         </rule>
         <rule header="A 'U' suffix shall be applied to all constants of unsigned type" id="10_6" impl="MISRA2004-10_6" quickfix="false" scope="line" severity="5">
            <file path="MISRA2004\MISRA2004-10_6.rule"/>
         </rule>
         <rule header="Conversions shall not be performed between a pointer to a function and any type other than an integral type" id="11_1" impl="MISRA2004-11_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_1.rule"/>
         </rule>
         <rule header="Conversions shall not be performed between a pointer to object and any type other than an integral type, another pointer to object type or a pointer to void" id="11_2" impl="MISRA2004-11_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_2.rule"/>
         </rule>
         <rule header="Conversions shall not be performed between a pointer to object and any type other than an integral type, another pointer to object type or a pointer to void" id="11_2_b" impl="MISRA2004-11_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_2_b.rule"/>
         </rule>
         <rule header="Conversions shall not be performed between a pointer to object and any type other than an integral type, another pointer to object type or a pointer to void" id="11_2_c" impl="MISRA2004-11_2_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_2_c.rule"/>
         </rule>
         <rule header="A cast should not convert a pointer type to an integral type" id="11_3_a" impl="MISRA2004-11_3_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_3_a.rule"/>
         </rule>
         <rule header="A cast should not convert an integral type to a pointer type" id="11_3_b" impl="MISRA2004-11_3_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_3_b.rule"/>
         </rule>
         <rule header="A cast should not be performed between a pointer to object type and a different pointer to object type" id="11_4" impl="MISRA2004-11_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_4.rule"/>
         </rule>
         <rule header="A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference" id="11_5" impl="MISRA2004-11_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_5.rule"/>
         </rule>
         <rule header="The comma operator shall not be used" id="12_10" impl="MISRA2004-12_10" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_10.rule"/>
         </rule>
         <rule header="The underlying bit representations of floating-point values shall not be used" id="12_12" impl="MISRA2004-12_12" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_12.rule"/>
         </rule>
         <rule header="The increment (++) and decrement (--) operators should not be mixed with other operators in an expression" id="12_13" impl="MISRA2004-12_13" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_13.rule"/>
         </rule>
         <rule header="Limited dependence should be placed on C's operator precedence rules in expressions" id="12_1_a" impl="MISRA2004-12_1_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_1_a.rule"/>
         </rule>
         <rule header="Limited dependence should be placed on C's operator precedence rules in expressions" id="12_1_b" impl="MISRA2004-12_1_b" quickfix="false" scope="line" severity="5">
            <file path="MISRA2004\MISRA2004-12_1_b.rule"/>
         </rule>
         <rule header="No parentheses are required for the operand of a unary operator" id="12_1_c" impl="MISRA2004-12_1_c" quickfix="false" scope="line" severity="5">
            <file path="MISRA2004\MISRA2004-12_1_c.rule"/>
         </rule>
         <rule header="Limited dependence should be placed on C's operator precedence rules in expressions" id="12_1_d" impl="MISRA2004-12_1_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_1_d.rule"/>
         </rule>
         <rule header="Use parentheses unless all operators in the expression are the same" id="12_1_e" impl="MISRA2004-12_1_e" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_1_e.rule"/>
         </rule>
         <rule header="Limited dependence should be placed on C's operator precedence rules in expressions" id="12_1_f" impl="MISRA2004-12_1_f" quickfix="false" scope="line" severity="5">
            <file path="MISRA2004\MISRA2004-12_1_f.rule"/>
         </rule>
         <rule header="The value of an expression shall be the same under any order of evaluation that the standard permits" id="12_2_a" impl="MISRA2004-12_2_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_a.rule"/>
         </rule>
         <rule header="Don't write code that depends on the order of evaluation of function arguments" id="12_2_b" impl="MISRA2004-12_2_b" quickfix="false" scope="line" severity="1">
            <file path="MISRA2004\MISRA2004-12_2_b.rule"/>
         </rule>
         <rule header="Don't write code that depends on the order of evaluation of function designator and function arguments" id="12_2_c" impl="MISRA2004-12_2_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_c.rule"/>
         </rule>
         <rule header="Don't write code that depends on the order of evaluation of expression that involves a function call" id="12_2_d" impl="MISRA2004-12_2_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_d.rule"/>
         </rule>
         <rule header="Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression" id="12_2_e" impl="MISRA2004-12_2_e" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_e.rule"/>
         </rule>
         <rule header="Do not use more than one volatile between two adjacent sequence points" id="12_2_f" impl="MISRA2004-12_2_f" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_f.rule"/>
         </rule>
         <rule header="Don't write code that depends on the order of evaluation of function calls" id="12_2_g" impl="MISRA2004-12_2_g" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_g.rule"/>
         </rule>
         <rule header="The operand of the sizeof operator shall not contain any expression which has side effects" id="12_3" impl="MISRA2004-12_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_3.rule"/>
         </rule>
         <rule header="Object designated by a volatile lvalue should not be accessed in the operand of the sizeof operator" id="12_3_b" impl="MISRA2004-12_3_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_3_b.rule"/>
         </rule>
         <rule header="The function call that causes the side effect shall not be the operand of the sizeof operator" id="12_3_c" impl="MISRA2004-12_3_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_3_c.rule"/>
         </rule>
         <rule header="The right-hand operand of a logical &amp;&amp; or || operator shall not contain side effects" id="12_4_a" impl="MISRA2004-12_4_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_4_a.rule"/>
         </rule>
         <rule header="The operands of a logical &amp;&amp; or || shall be primary-expressions" id="12_5" impl="MISRA2004-12_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_5.rule"/>
         </rule>
         <rule header="The operands of logical operators (&amp;&amp;, || and !) should be effectively Boolean" id="12_6_a" impl="MISRA2004-12_6_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_6_a.rule"/>
         </rule>
         <rule header="Expressions that are effectively Boolean should not be used as operands to operators other than (&amp;&amp;, ||, !, =, ==, !=, ?:)" id="12_6_b" impl="MISRA2004-12_6_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_6_b.rule"/>
         </rule>
         <rule header="Bitwise operators shall not be applied to operands whose underlying type is signed" id="12_7" impl="MISRA2004-12_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_7.rule"/>
         </rule>
         <rule header="The right-hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left-hand operand" id="12_8" impl="MISRA2004-12_8" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_8.rule"/>
         </rule>
         <rule header="The unary minus operator shall not be applied to an expression whose underlying type is unsigned" id="12_9" impl="MISRA2004-12_9" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_9.rule"/>
         </rule>
         <rule header="Assignment operators shall not be used in expressions that yield a Boolean value" id="13_1" impl="MISRA2004-13_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_1.rule"/>
         </rule>
         <rule header="Tests of a value against zero should be made explicit, unless the operand is effectively Boolean" id="13_2" impl="MISRA2004-13_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_2.rule"/>
         </rule>
         <rule header="Floating-point expressions shall not be tested for equality or inequality" id="13_3" impl="MISRA2004-13_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_3.rule"/>
         </rule>
         <rule header="The controlling expression of a for statement shall not contain any objects of floating type" id="13_4" impl="MISRA2004-13_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_4.rule"/>
         </rule>
         <rule header="The three expressions of a for statement shall be concerned only with loop control" id="13_5" impl="MISRA2004-13_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_5.rule"/>
         </rule>
         <rule header="Do not modify for loop counter within a body of the loop" id="13_6" impl="MISRA2004-13_6" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_6.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_a" impl="MISRA2004-13_7_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_a.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_aa" impl="MISRA2004-13_7_aa" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_aa.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_ab" impl="MISRA2004-13_7_ab" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ab.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_ac" impl="MISRA2004-13_7_ac" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ac.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_ad" impl="MISRA2004-13_7_ad" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ad.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_ae" impl="MISRA2004-13_7_ae" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ae.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_af" impl="MISRA2004-13_7_af" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_af.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_ag" impl="MISRA2004-13_7_ag" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ag.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_ah" impl="MISRA2004-13_7_ah" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ah.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_ai" impl="MISRA2004-13_7_ai" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ai.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_aj" impl="MISRA2004-13_7_aj" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_aj.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_ak" impl="MISRA2004-13_7_ak" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ak.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_b" impl="MISRA2004-13_7_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_b.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_c" impl="MISRA2004-13_7_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_c.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_d" impl="MISRA2004-13_7_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_d.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_j" impl="MISRA2004-13_7_j" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_j.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_k" impl="MISRA2004-13_7_k" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_k.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_l" impl="MISRA2004-13_7_l" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_l.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_m" impl="MISRA2004-13_7_m" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_m.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_n" impl="MISRA2004-13_7_n" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_n.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_s" impl="MISRA2004-13_7_s" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_s.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_t" impl="MISRA2004-13_7_t" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_t.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_u" impl="MISRA2004-13_7_u" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_u.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_v" impl="MISRA2004-13_7_v" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_v.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_w" impl="MISRA2004-13_7_w" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_w.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_x" impl="MISRA2004-13_7_x" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_x.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_y" impl="MISRA2004-13_7_y" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_y.rule"/>
         </rule>
         <rule header="Boolean operations whose results are invariant shall not be permitted" id="13_7_z" impl="MISRA2004-13_7_z" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_z.rule"/>
         </rule>
         <rule header="All 'if...else-if' constructs shall be terminated with an 'else' clause" id="14_10" impl="MISRA2004-14_10" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_10.rule"/>
         </rule>
         <rule header="There shall be no unreachable code in &quot;else&quot; block" id="14_1_a" impl="MISRA2004-14_1_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_a.rule"/>
         </rule>
         <rule header="There shall be no unreachable code after 'return', 'break', 'continue', and 'goto' statements" id="14_1_b" impl="MISRA2004-14_1_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_b.rule"/>
         </rule>
         <rule header="There shall be no unreachable code in &quot;if/else/while/for&quot; block" id="14_1_c" impl="MISRA2004-14_1_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_c.rule"/>
         </rule>
         <rule header="There shall be no unreachable code in switch statement" id="14_1_d" impl="MISRA2004-14_1_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_d.rule"/>
         </rule>
         <rule header="There shall be no unreachable code in 'for' loop" id="14_1_e" impl="MISRA2004-14_1_e" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_e.rule"/>
         </rule>
         <rule header="There shall be no unreachable code after 'if' or 'switch' statement" id="14_1_f" impl="MISRA2004-14_1_f" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_f.rule"/>
         </rule>
         <rule header="There shall be no unreachable code after &quot;if&quot; or &quot;switch&quot; statement inside while/for/do...while loop" id="14_1_g" impl="MISRA2004-14_1_g" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_g.rule"/>
         </rule>
         <rule header="All non-null statements shall either have at least one side-effect however executed or cause control flow to change" id="14_2" impl="MISRA2004-14_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_2.rule"/>
         </rule>
         <rule header="Null statement shall only occur on a line by itself or it may be followed by a comment" id="14_3" impl="MISRA2004-14_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_3.rule"/>
         </rule>
         <rule header="The goto statement shall not be used" id="14_4" impl="MISRA2004-14_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_4.rule"/>
         </rule>
         <rule header="The continue statement shall not be used" id="14_5" impl="MISRA2004-14_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_5.rule"/>
         </rule>
         <rule header="For any iteration statement there shall be at most one break statement used for loop termination" id="14_6" impl="MISRA2004-14_6" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_6.rule"/>
         </rule>
         <rule header="A function shall have a single point of exit at the end of the function" id="14_7" impl="MISRA2004-14_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_7.rule"/>
         </rule>
         <rule header="The statement forming the body of a 'switch', 'while', 'do...while' or 'for' statement shall be a compound statement" id="14_8" impl="MISRA2004-14_8" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_8.rule"/>
         </rule>
         <rule header="'if' and 'else' should be followed by a compound statement" id="14_9" impl="MISRA2004-14_9" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_9.rule"/>
         </rule>
         <rule header="A break statement should be placed only at the end of switch clause" id="15_0_a" impl="MISRA2004-15_0_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_0_a.rule"/>
         </rule>
         <rule header="A switch statement shall only contain switch labels and switch clauses, and no other code" id="15_0_b" impl="MISRA2004-15_0_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_0_b.rule"/>
         </rule>
         <rule header="A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" id="15_1" impl="MISRA2004-15_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_1.rule"/>
         </rule>
         <rule header="An unconditional break statement shall terminate every non-empty case clause" id="15_2" impl="MISRA2004-15_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_2.rule"/>
         </rule>
         <rule header="An unconditional break statement shall terminate every non-empty default clause" id="15_2_b" impl="MISRA2004-15_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_2_b.rule"/>
         </rule>
         <rule header="The final clause of a switch statement shall be the default clause" id="15_3" impl="MISRA2004-15_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_3.rule"/>
         </rule>
         <rule header="A switch expression shall not represent a value that is effectively Boolean" id="15_4" impl="MISRA2004-15_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_4.rule"/>
         </rule>
         <rule header="A switch expression shall not represent a value that is effectively Boolean" id="15_4_b" impl="MISRA2004-15_4_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_4_b.rule"/>
         </rule>
         <rule header="Every switch statement shall have at least one case clause" id="15_5" impl="MISRA2004-15_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_5.rule"/>
         </rule>
         <rule header="Functions shall not be defined with a variable number of arguments" id="16_1" impl="MISRA2004-16_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_1.rule"/>
         </rule>
         <rule header="If a function returns error information, then that error information shall be tested" id="16_10" impl="MISRA2004-16_10" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_10.rule"/>
         </rule>
         <rule header="Functions shall not call themselves, either directly or indirectly" id="16_2" impl="MISRA2004-16_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_2.rule"/>
         </rule>
         <rule header="Identifiers shall be given for all of the parameters in a function prototype declaration" id="16_3" impl="MISRA2004-16_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_3.rule"/>
         </rule>
         <rule header="The identifiers used in the declaration and definition of a function shall be identical" id="16_4" impl="MISRA2004-16_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_4.rule"/>
         </rule>
         <rule header="Functions with no parameters shall be declared with parameter type void" id="16_5" impl="MISRA2004-16_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_5.rule"/>
         </rule>
         <rule header="The number of arguments passed to a function shall match the number of parameters" id="16_6" impl="MISRA2004-16_6" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_6.rule"/>
         </rule>
         <rule header="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" id="16_7" impl="MISRA2004-16_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_7.rule"/>
         </rule>
         <rule header="Declare a type of parameter as typedef to pointer to const if the pointer is not used to modify the addressed object" id="16_7_b" impl="MISRA2004-16_7_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_7_b.rule"/>
         </rule>
         <rule header="All exit paths from a function with non-void return type shall have an explicit return statement with an expression" id="16_8" impl="MISRA2004-16_8" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_8.rule"/>
         </rule>
         <rule header="A function identifier shall only be used with either a preceding '&amp;', or with a parenthesised parameter list, which may be empty" id="16_9" impl="MISRA2004-16_9" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_9.rule"/>
         </rule>
         <rule header="Do not apply arithmetic to pointers that don't address an array or array element" id="17_1" impl="MISRA2004-17_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-17_1.rule"/>
         </rule>
         <rule header="Pointer arithmetic shall only be applied to pointers that address an array or array element" id="17_2" impl="MISRA2004-17_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-17_2.rule"/>
         </rule>
         <rule header="&gt;, &gt;=, &lt;, &lt;= shall not be applied to pointer types except where they point to the same array" id="17_3" impl="MISRA2004-17_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-17_3.rule"/>
         </rule>
         <rule header="Array indexing shall be the only allowed form of pointer arithmetic" id="17_4" impl="MISRA2004-17_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-17_4.rule"/>
         </rule>
         <rule header="The declaration of objects should contain no more than 2 levels of pointer indirection" id="17_5" impl="MISRA2004-17_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-17_5.rule"/>
         </rule>
         <rule header="The address of an object with automatic storage shall not be returned from a function" id="17_6_a" impl="MISRA2004-17_6_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-17_6_a.rule"/>
         </rule>
         <rule header="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="17_6_b" impl="MISRA2004-17_6_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-17_6_b.rule"/>
         </rule>
         <rule header="All structure and union types shall be complete at the end of a translation unit" id="18_1" impl="MISRA2004-18_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-18_1.rule"/>
         </rule>
         <rule header="An object shall not be assigned to an overlapping object" id="18_2" impl="MISRA2004-18_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-18_2.rule"/>
         </rule>
         <rule header="An object shall not be assigned to an overlapping object" id="18_2_b" impl="MISRA2004-18_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-18_2_b.rule"/>
         </rule>
         <rule header="Unions shall not be used" id="18_4" impl="MISRA2004-18_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-18_4.rule"/>
         </rule>
         <rule header="#include statements in a file should only be preceded by other preprocessor directives or comments" id="19_1" impl="MISRA2004-19_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_1.rule"/>
         </rule>
         <rule header="In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ##" id="19_10" impl="MISRA2004-19_10" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_10.rule"/>
         </rule>
         <rule header="Do not use in preprocessor directives #if and #elif macros not defined in translation unit" id="19_11_b" impl="MISRA2004-19_11_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_11_b.rule"/>
         </rule>
         <rule header="There shall be at most one occurrence of the # or ## preprocessor operators in a single macro definition" id="19_12" impl="MISRA2004-19_12" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_12.rule"/>
         </rule>
         <rule header="The # and ## preprocessor operators should not be used" id="19_13" impl="MISRA2004-19_13" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_13.rule"/>
         </rule>
         <rule header="The defined preprocessor operator shall only be used in one of the two standard forms" id="19_14" impl="MISRA2004-19_14" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_14.rule"/>
         </rule>
         <rule header="Precautions shall be taken in order to prevent the contents of a header file being included twice" id="19_15" impl="MISRA2004-19_15" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_15.rule"/>
         </rule>
         <rule header="Preprocessing directives shall be syntactically meaningful even when excluded by the preprocessor" id="19_16" impl="MISRA2004-19_16" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_16.rule"/>
         </rule>
         <rule header="All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if or #ifdef directive to which they are related" id="19_17" impl="MISRA2004-19_17" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_17.rule"/>
         </rule>
         <rule header="Non-standard characters should not occur in header file names in #include directives" id="19_2" impl="MISRA2004-19_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_2.rule"/>
         </rule>
         <rule header="Avoid keywords and basic types in macros" id="19_4" impl="MISRA2004-19_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_4.rule"/>
         </rule>
         <rule header="Macros shall not be #define'd or #undef'd within a block" id="19_5" impl="MISRA2004-19_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_5.rule"/>
         </rule>
         <rule header="#undef shall not be used" id="19_6" impl="MISRA2004-19_6" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_6.rule"/>
         </rule>
         <rule header="A function should be used in preference to a function-like macro" id="19_7" impl="MISRA2004-19_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_7.rule"/>
         </rule>
         <rule header="A function-like macro shall not be invoked without all of its arguments" id="19_8" impl="MISRA2004-19_8" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_8.rule"/>
         </rule>
         <rule header="Arguments to a function-like macro shall not contain tokens that look like preprocessing directives" id="19_9" impl="MISRA2004-19_9" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_9.rule"/>
         </rule>
         <rule header="The library functions atof, atoi and atol from library stdlib.h shall not be used" id="20_10" impl="MISRA2004-20_10" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_10.rule"/>
         </rule>
         <rule header="The library functions abort, exit, getenv and system from library stdlib.h shall not be used" id="20_11" impl="MISRA2004-20_11" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_11.rule"/>
         </rule>
         <rule header="The time handling functions of library time.h shall not be used" id="20_12" impl="MISRA2004-20_12" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_12.rule"/>
         </rule>
         <rule header="Do not #define or #undef identifiers with names which start with underscore" id="20_1_a" impl="MISRA2004-20_1_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_1_a.rule"/>
         </rule>
         <rule header="Do not redefine reserved words" id="20_1_b" impl="MISRA2004-20_1_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_1_b.rule"/>
         </rule>
         <rule header="Do not #define nor #undef identifier 'defined'" id="20_1_e" impl="MISRA2004-20_1_e" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_1_e.rule"/>
         </rule>
         <rule header="The names of standard library macros, objects and functions shall not be reused" id="20_2" impl="MISRA2004-20_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_2.rule"/>
         </rule>
         <rule header="The names of standard library macros, objects and functions shall not be reused (C90)" id="20_2_a" impl="MISRA2004-20_2_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_2_a.rule"/>
         </rule>
         <rule header="The names of standard library macros, objects and functions shall not be reused (C99)" id="20_2_b" impl="MISRA2004-20_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_2_b.rule"/>
         </rule>
         <rule header="The validity of values passed to library functions shall be checked" id="20_3" impl="MISRA2004-20_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_3.rule"/>
         </rule>
         <rule header="Dynamic heap memory allocation shall not be used" id="20_4" impl="MISRA2004-20_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_4.rule"/>
         </rule>
         <rule header="The error indicator errno shall not be used" id="20_5" impl="MISRA2004-20_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_5.rule"/>
         </rule>
         <rule header="The macro offsetof, in library stddef.h, shall not be used" id="20_6" impl="MISRA2004-20_6" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_6.rule"/>
         </rule>
         <rule header="The setjmp macro and the longjmp function shall not be used" id="20_7" impl="MISRA2004-20_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_7.rule"/>
         </rule>
         <rule header="The standard header file &lt;setjmp.h&gt; shall not be used" id="20_7_b" impl="MISRA2004-20_7_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_7_b.rule"/>
         </rule>
         <rule header="The standard header file &lt;signal.h&gt; shall not be used" id="20_8" impl="MISRA2004-20_8" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_8.rule"/>
         </rule>
         <rule header="The signal handling facilities of &lt;signal.h&gt; shall not be used" id="20_8_b" impl="MISRA2004-20_8_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_8_b.rule"/>
         </rule>
         <rule header="The input/output library stdio.h shall not be used" id="20_9" impl="MISRA2004-20_9" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_9.rule"/>
         </rule>
         <rule header="Assembly language shall be encapsulated and isolated" id="2_1" impl="MISRA2004-2_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-2_1.rule"/>
         </rule>
         <rule header="Source code shall only use /* ... */ style comments" id="2_2" impl="MISRA2004-2_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-2_2.rule"/>
         </rule>
         <rule header="The character sequence /* shall not be used within a C-style comment" id="2_3" impl="MISRA2004-2_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-2_3.rule"/>
         </rule>
         <rule header="Sections of code should not be &quot;commented out&quot;" id="2_4" impl="MISRA2004-2_4" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-2_4.rule"/>
         </rule>
         <rule header="All uses of the #pragma directive shall be documented and explained" id="3_4" impl="MISRA2004-3_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-3_4.rule"/>
         </rule>
         <rule header="Do not mix bit-fields and other data within the same structure" id="3_5" impl="MISRA2004-3_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-3_5.rule"/>
         </rule>
         <rule header="Only those escape sequences that are defined in the ISO C standard shall be used" id="4_1" impl="MISRA2004-4_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-4_1.rule"/>
         </rule>
         <rule header="Trigraphs shall not be used" id="4_2" impl="MISRA2004-4_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-4_2.rule"/>
         </rule>
         <rule header="Identifiers (internal and external) shall not rely on the significance of more than 31 characters" id="5_1" impl="MISRA2004-5_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_1.rule"/>
         </rule>
         <rule header="Identifier declared in a local or function prototype scope shall not hide an identifier declared in a global or namespace scope" id="5_2_a" impl="MISRA2004-5_2_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_2_a.rule"/>
         </rule>
         <rule header="Identifiers declared in an inner local scope should not hide identifiers declared in an outer local scope" id="5_2_b" impl="MISRA2004-5_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_2_b.rule"/>
         </rule>
         <rule header="Do not reuse typedef names" id="5_3_a" impl="MISRA2004-5_3_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_3_a.rule"/>
         </rule>
         <rule header="Do not reuse typedef names as a typedef name" id="5_3_b" impl="MISRA2004-5_3_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_3_b.rule"/>
         </rule>
         <rule header="A tag name shall not be reused for other purpose within the program" id="5_4_a" impl="MISRA2004-5_4_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_4_a.rule"/>
         </rule>
         <rule header="A tag name shall not be reused to define a different tag" id="5_4_b" impl="MISRA2004-5_4_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_4_b.rule"/>
         </rule>
         <rule header="The name of typedef should not be the same as the name of type that is typedef'd" id="5_4_c" impl="MISRA2004-5_4_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_4_c.rule"/>
         </rule>
         <rule header="No object or function identifier with static storage duration should be reused" id="5_5_a" impl="MISRA2004-5_5_a" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-5_5_a.rule"/>
         </rule>
         <rule header="No object or function identifier with static storage duration should be reused" id="5_5_b" impl="MISRA2004-5_5_b" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-5_5_b.rule"/>
         </rule>
         <rule header="No identifier in one name space should have the same spelling as an identifier in another name space, with the exception of structure and union member names" id="5_6" impl="MISRA2004-5_6" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-5_6.rule"/>
         </rule>
         <rule header="No identifier name should be reused" id="5_7" impl="MISRA2004-5_7" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-5_7.rule"/>
         </rule>
         <rule header="The plain char type shall be used only for the storage and use of character values" id="6_1" impl="MISRA2004-6_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_1.rule"/>
         </rule>
         <rule header="signed and unsigned char type shall be used only for the storage and use of numeric values" id="6_2" impl="MISRA2004-6_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_2.rule"/>
         </rule>
         <rule header="typedefs to basic types should contain some digits in their name" id="6_3" impl="MISRA2004-6_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_3.rule"/>
         </rule>
         <rule header="typedefs should be used in place of the basic types" id="6_3_b" impl="MISRA2004-6_3_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_3_b.rule"/>
         </rule>
         <rule header="Bit fields shall only be defined to be of type unsigned int or signed int" id="6_4" impl="MISRA2004-6_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_4.rule"/>
         </rule>
         <rule header="Unnamed bit-fields with signed integer type shall have a length of more than one bit" id="6_5_a" impl="MISRA2004-6_5_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_5_a.rule"/>
         </rule>
         <rule header="Octal constants (other than zero) shall not be used" id="7_1_a" impl="MISRA2004-7_1_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-7_1_a.rule"/>
         </rule>
         <rule header="Octal escape sequences shall not be used" id="7_1_b" impl="MISRA2004-7_1_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-7_1_b.rule"/>
         </rule>
         <rule header="The static storage class specifier shall be used in definitions and declarations of objects and functions that have internal linkage" id="8_11" impl="MISRA2004-8_11" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_11.rule"/>
         </rule>
         <rule header="When an array is declared with external linkage, its size shall be stated explicitly or defined implicitly by initialisation" id="8_12" impl="MISRA2004-8_12" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_12.rule"/>
         </rule>
         <rule header="Whenever a function is declared or defined, its type shall be explicitly stated" id="8_2_a" impl="MISRA2004-8_2_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_2_a.rule"/>
         </rule>
         <rule header="Whenever an object is declared or defined, its type shall be explicitly stated" id="8_2_b" impl="MISRA2004-8_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_2_b.rule"/>
         </rule>
         <rule header="Use identical types in declaration and definition" id="8_3_a" impl="MISRA2004-8_3_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_3_a.rule"/>
         </rule>
         <rule header="Use identical types in declaration and definition" id="8_3_b" impl="MISRA2004-8_3_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_3_b.rule"/>
         </rule>
         <rule header="If objects or functions are declared more than once their types shall be compatible" id="8_4" impl="MISRA2004-8_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_4.rule"/>
         </rule>
         <rule header="There shall be no definitions of objects or functions in a header file" id="8_5" impl="MISRA2004-8_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_5.rule"/>
         </rule>
         <rule header="Always declare functions at file scope" id="8_6" impl="MISRA2004-8_6" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_6.rule"/>
         </rule>
         <rule header="Objects shall be defined at block scope if they are only accessed from within a single function" id="8_7" impl="MISRA2004-8_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_7.rule"/>
         </rule>
         <rule header="Arrays shall not be partially initialized" id="9_2_b" impl="MISRA2004-9_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-9_2_b.rule"/>
         </rule>
         <rule header="The non-zero initialization of structures requires an explicit initializer for each element" id="9_2_c" impl="MISRA2004-9_2_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-9_2_c.rule"/>
         </rule>
         <rule header="In an enumerator list, the &quot;=&quot; construct shall not be used to explicitly initialise members other than the first, unless all items are explicitly initialised" id="9_3" impl="MISRA2004-9_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-9_3.rule"/>
         </rule>
      </category>
      <category description="Memory and Resource Management" name="MRM">
         <rule header="Do not allocate resources in function argument list because the order of evaluation of a function's parameters is undefined" id="01" impl="MRM-01" quickfix="false" scope="line" severity="1">
            <file path="MRM\MRM-01.rule"/>
         </rule>
         <rule header="Do not allocate more than one resource in a single statement" id="02" impl="MRM-02" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-02.rule"/>
         </rule>
         <rule header="All classes should contain the assignment operator or appropriate comment" id="04" impl="MRM-04" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-04.rule"/>
         </rule>
         <rule header="All classes should contain the copy constructor or appropriate comment" id="05" impl="MRM-05" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-05.rule"/>
         </rule>
         <rule header="Use the same form in corresponding calls to new/malloc and delete/free" id="06" impl="MRM-06" quickfix="false" scope="line" severity="1">
            <file path="MRM\MRM-06.rule"/>
         </rule>
         <rule header="Don't memcpy or memcmp non-PODs" id="07" impl="MRM-07" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-07.rule"/>
         </rule>
         <rule header="Do not invoke malloc/realloc for objects having constructors" id="08" impl="MRM-08" quickfix="false" scope="line" severity="1">
            <file path="MRM\MRM-08.rule"/>
         </rule>
         <rule header="Always assign a new value to an expression that points to deallocated memory" id="09" impl="MRM-09" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-09.rule"/>
         </rule>
         <rule header="Always assign a new value to global or member variable that points to deallocated memory" id="10" impl="MRM-10" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-10.rule"/>
         </rule>
         <rule header="Always assign a new value to parameter or local variable that points to deallocated memory" id="11" impl="MRM-11" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-11.rule"/>
         </rule>
         <rule header="Adhere to convention when writing new and delete" id="12" impl="MRM-12" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-12.rule"/>
         </rule>
         <rule header="Adhere to convention when writing new" id="13" impl="MRM-13" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-13.rule"/>
         </rule>
         <rule header="If a class defines any overload of operator new, it should provide overloads of all three of plain, in-place, and non-throwing operator new" id="14" impl="MRM-14" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-14.rule"/>
         </rule>
         <rule header="If a class defines any overload of operator new[], it should provide overloads of all three of plain, in-place, and non-throwing operator new[]" id="15" impl="MRM-15" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-15.rule"/>
         </rule>
         <rule header="If a class defines any overload of operator delete, it should provide overloads of all three of plain, in-place, and non-throwing operator delete" id="16" impl="MRM-16" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-16.rule"/>
         </rule>
         <rule header="If a class defines any overload of operator delete[], it should provide overloads of all three of plain, in-place, and non-throwing operator delete[]" id="17" impl="MRM-17" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-17.rule"/>
         </rule>
         <rule header="Do not allocate memory and expect that someone else will deallocate it later" id="18" impl="MRM-18" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-18.rule"/>
         </rule>
         <rule header="Do not allocate memory and expect that someone else will deallocate it later" id="19" impl="MRM-19" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-19.rule"/>
         </rule>
         <rule header="Do not allocate memory and expect that someone else will deallocate it later" id="20" impl="MRM-20" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-20.rule"/>
         </rule>
         <rule header="Use objects to manage resources" id="21" impl="MRM-21" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-21.rule"/>
         </rule>
         <rule header="Use objects to manage resources" id="22" impl="MRM-22" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-22.rule"/>
         </rule>
         <rule header="Never return a dereferenced local pointer initialized by new in this function scope" id="23" impl="MRM-23" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-23.rule"/>
         </rule>
         <rule header="Store newed objects in smart pointers in standalone statements" id="25" impl="MRM-25" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-25.rule"/>
         </rule>
         <rule header="Write operator delete if you write operator new" id="26" impl="MRM-26" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-26.rule"/>
         </rule>
         <rule header="Write operator delete[] if you write operator new[]" id="27" impl="MRM-27" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-27.rule"/>
         </rule>
         <rule header="Always provide new and delete together" id="28" impl="MRM-28" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-28.rule"/>
         </rule>
         <rule header="Always provide new[] and delete[] together" id="29" impl="MRM-29" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-29.rule"/>
         </rule>
         <rule header="Use allocation by declaration rather than by new or malloc" id="30" impl="MRM-30" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-30.rule"/>
         </rule>
         <rule header="Freed memory shouldn't be accessed under any circumstances" id="31" impl="MRM-31" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-31.rule"/>
         </rule>
         <rule header="Destructor should not be called manually" id="31_b" impl="MRM-31_b" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-31_b.rule"/>
         </rule>
         <rule header="Avoid hiding the global new" id="32" impl="MRM-32" quickfix="false" scope="line" severity="1">
            <file path="MRM\MRM-32.rule"/>
         </rule>
         <rule header="Call delete on pointer members in destructors" id="33" impl="MRM-33" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-33.rule"/>
         </rule>
         <rule header="Check the return value of new" id="34" impl="MRM-34" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-34.rule"/>
         </rule>
         <rule header="Never provide brackets ([]) for delete when deallocating non-arrays" id="35" impl="MRM-35" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-35.rule"/>
         </rule>
         <rule header="Always provide empty brackets ([]) for delete when deallocating arrays" id="36" impl="MRM-36" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-36.rule"/>
         </rule>
         <rule header="Declare a copy assignment operator for classes with dynamically allocated memory" id="37" impl="MRM-37" quickfix="false" scope="line" severity="1">
            <file path="MRM\MRM-37.rule"/>
         </rule>
         <rule header="Declare a copy constructor for classes with dynamically allocated memory" id="38" impl="MRM-38" quickfix="false" scope="line" severity="1">
            <file path="MRM\MRM-38.rule"/>
         </rule>
         <rule header="Provide error handling for file opening errors right next to the call to fopen" id="39" impl="MRM-39" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-39.rule"/>
         </rule>
         <rule header="Copy and destroy consistently" id="40" impl="MRM-40" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-40.rule"/>
         </rule>
         <rule header="A copy assignment operator should be declared when a copy constructor is declared (and vice versa)" id="40_a" impl="MRM-40_a" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-40_a.rule"/>
         </rule>
         <rule header="Both the copy constructor and copy assignment operator should have the same public/protected/private permission" id="40_b" impl="MRM-40_b" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-40_b.rule"/>
         </rule>
         <rule header="If you have a non-trivial copy constructor or copy assignment operator, you should also declare a destructor" id="40_c" impl="MRM-40_c" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-40_c.rule"/>
         </rule>
         <rule header="Both copy constructor and copy assignment operator should be declared for classes with a nontrivial destructor" id="40_d" impl="MRM-40_d" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-40_d.rule"/>
         </rule>
         <rule header="A copy constructor shall copy all data members and bases" id="41" impl="MRM-41" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-41.rule"/>
         </rule>
         <rule header="Call fclose() on pointer member in destructor if the pointer was used to open a file" id="42" impl="MRM-42" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-42.rule"/>
         </rule>
         <rule header="An assignment operator shall assign all data bases" id="43" impl="MRM-43" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-43.rule"/>
         </rule>
         <rule header="Do not use sizeof operator on pointer type to specify the size of the memory to be allocated via 'malloc', 'calloc' or 'realloc' function" id="45" impl="MRM-45" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-45.rule"/>
         </rule>
         <rule header="Do not use calloc, malloc, realloc and free functions" id="46" impl="MRM-46" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-46.rule"/>
         </rule>
         <rule header="Classes containing at least one non-static member variable should declare the assignment operator or contain appropriate comment" id="47" impl="MRM-47" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-47.rule"/>
         </rule>
         <rule header="Classes containing at least one non-static member variable should declare the copy constructor or contain appropriate comment" id="48" impl="MRM-48" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-48.rule"/>
         </rule>
         <rule header="A copy constructor and a copy assignment operator shall be declared for classes that contain pointers to data items or nontrivial destructors" id="49" impl="MRM-49" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-49.rule"/>
         </rule>
         <rule header="Declare both private copy constructor and copy assignment operator at the same time" id="50" impl="MRM-50" quickfix="false" scope="line" severity="4">
            <file path="MRM\MRM-50.rule"/>
         </rule>
         <rule header="Do not use 'delete' on pointers to a void type" id="51" impl="MRM-51" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-51.rule"/>
         </rule>
         <rule header="Use RAII to prevent resource leaks" id="52" impl="MRM-52" quickfix="false" scope="line" severity="4">
            <file path="MRM\MRM-52.rule"/>
         </rule>
         <rule header="The user defined 'new' operator should throw the 'std::bad_alloc' exception when the allocation fails" id="53" impl="MRM-53" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-53.rule"/>
         </rule>
         <rule header="Avoid using the default operator 'new' for over-aligned types" id="54" impl="MRM-54" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-54.rule"/>
         </rule>
         <rule header="Do not pass a pointer that has insufficient storage capacity or that is not suitably aligned for the object being constructed to placement 'new'" id="55" impl="MRM-55" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-55.rule"/>
         </rule>
         <rule header="An overhead should be used when an array of objects is passed to the placement 'new' allocation function" id="55_b" impl="MRM-55_b" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-55_b.rule"/>
         </rule>
      </category>
      <category description="Naming Conventions" name="NAMING">
         <rule header="All &quot;#define&quot; constants shall be in uppercase" id="01" impl="NAMING-01" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-01.rule"/>
         </rule>
         <rule header="In an enumerated list, list members (elements) shall be in uppercase and names or tags for the list shall be in lowercase" id="02" impl="NAMING-02" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-02.rule"/>
         </rule>
         <rule header="Use lowercase for file names" id="03" impl="NAMING-03" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-03.rule"/>
         </rule>
         <rule header="Global prefixes should only be used for global variables" id="04" impl="NAMING-04" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-04.rule"/>
         </rule>
         <rule header="Begin local variable names with a lowercase letters" id="05" impl="NAMING-05" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-05.rule"/>
         </rule>
         <rule header="Begin global variable names with a lowercase letters" id="06" impl="NAMING-06" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-06.rule"/>
         </rule>
         <rule header="Begin member variable names with a lowercase letters" id="07" impl="NAMING-07" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-07.rule"/>
         </rule>
         <rule header="Begin all boolean type variables with 'b'" id="08" impl="NAMING-08" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-08.rule"/>
         </rule>
         <rule header="Begin class, struct, union, enum, and typedef names with an uppercase letter" id="09" impl="NAMING-09" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-09.rule"/>
         </rule>
         <rule header="The names of abstract data types, structures, typedefs, and enumerated types are to begin with an uppercase letter" id="10" impl="NAMING-10" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-10.rule"/>
         </rule>
         <rule header="The name of enumeration type shall begin with an uppercase letter and contain a suffix '_t' at the end" id="11" impl="NAMING-11" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-11.rule"/>
         </rule>
         <rule header="The names of structures shall begin with an uppercase letter and contain a suffix '_t' at the end" id="12" impl="NAMING-12" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-12.rule"/>
         </rule>
         <rule header="Begin constant variables with 'c'" id="13" impl="NAMING-13" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-13.rule"/>
         </rule>
         <rule header="Begin class data member names with 'its'" id="14" impl="NAMING-14" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-14.rule"/>
         </rule>
         <rule header="Begin all double type variable with 'd'" id="15" impl="NAMING-15" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-15.rule"/>
         </rule>
         <rule header="Begin all float type variables with 'f'" id="16" impl="NAMING-16" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-16.rule"/>
         </rule>
         <rule header="Begin all function names with uppercase letter" id="17" impl="NAMING-17" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-17.rule"/>
         </rule>
         <rule header="Begin global variable names with 'the'" id="18" impl="NAMING-18" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-18.rule"/>
         </rule>
         <rule header="Begin all integer type variable with 'i'" id="19" impl="NAMING-19" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-19.rule"/>
         </rule>
         <rule header="Functions that begin with 'is' should return boolean values" id="20" impl="NAMING-20" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-20.rule"/>
         </rule>
         <rule header="Begin all long integer variables with 'li'" id="21" impl="NAMING-21" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-21.rule"/>
         </rule>
         <rule header="Prefix a variable type 'pointer' with a 'p' character" id="22" impl="NAMING-22" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-22.rule"/>
         </rule>
         <rule header="Begin all short integer variables with 'si'" id="23" impl="NAMING-23" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-23.rule"/>
         </rule>
         <rule header="Begin all signed character variables with 'c'" id="24" impl="NAMING-24" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-24.rule"/>
         </rule>
         <rule header="Begin all terminated characters string variables with 'sz'" id="25" impl="NAMING-25" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-25.rule"/>
         </rule>
         <rule header="Begin all unsigned character type variables with 'uc'" id="26" impl="NAMING-26" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-26.rule"/>
         </rule>
         <rule header="Begin all unsigned integer type variables with 'ui'" id="27" impl="NAMING-27" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-27.rule"/>
         </rule>
         <rule header="Use lowercase letters for structure and union member names" id="28" impl="NAMING-28" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-28.rule"/>
         </rule>
         <rule header="Append names of non-scalar typedefs with &quot;_t&quot;" id="29" impl="NAMING-29" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-29.rule"/>
         </rule>
         <rule header="Implementation files in C always have the file name extension &quot;.c&quot;" id="30" impl="NAMING-30" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-30.rule"/>
         </rule>
         <rule header="Do not use typenames that differ only by the use of uppercase and lowercase letters" id="31" impl="NAMING-31" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-31.rule"/>
         </rule>
         <rule header="An include file for a class should have a file name of the form &lt;class name&gt; + extension" id="32" impl="NAMING-32" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-32.rule"/>
         </rule>
         <rule header="Do not use identifiers which begin with one or two underscores (`_' or `__')" id="33" impl="NAMING-33" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-33.rule"/>
         </rule>
         <rule header="Global function names should start with lowercase" id="34" impl="NAMING-34" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-34.rule"/>
         </rule>
         <rule header="Member function names should start with lowercase" id="35" impl="NAMING-35" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-35.rule"/>
         </rule>
         <rule header="Names of parameters in declaration and definition should be identical" id="36" impl="NAMING-36" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-36.rule"/>
         </rule>
         <rule header="Include files in C++ always have the file name extension '.hh'" id="37" impl="NAMING-37" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-37.rule"/>
         </rule>
         <rule header="Implementation files in C++ always have the file name extension &quot;.cc&quot;" id="38" impl="NAMING-38" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-38.rule"/>
         </rule>
         <rule header="Inline definition files always have the file name extension &quot;.icc&quot;" id="39" impl="NAMING-39" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-39.rule"/>
         </rule>
         <rule header="Only the first word of the name of a class, structure, namespace, enumeration, or typedef will begin with an uppercase letter" id="40" impl="NAMING-40" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-40.rule"/>
         </rule>
         <rule header="Header files will always have a file name extension of '.h'" id="41" impl="NAMING-41" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-41.rule"/>
         </rule>
         <rule header="Identifiers for constant and enumerator values shall be lowercase" id="42" impl="NAMING-42" quickfix="false" scope="line" severity="2">
            <file path="NAMING\NAMING-42.rule"/>
         </rule>
         <rule header="File name extension, if present, should be &quot;*.cpp&quot; or &quot;*.h&quot;" id="43" impl="NAMING-43" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-43.rule"/>
         </rule>
         <rule header="All letters contained in function and variable names will be composed entirely of lowercase letters" id="44" impl="NAMING-44" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-44.rule"/>
         </rule>
         <rule header="Identifiers will not differ by mixture of case, the underscore character, interchange of the similarly looking letters and numbers" id="45" impl="NAMING-45" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-45.rule"/>
         </rule>
         <rule header="The ', &quot;, /* or // characters shall not occur in a header file name" id="46" impl="NAMING-46" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-46.rule"/>
         </rule>
         <rule header="Different identifiers shall be typographically unambiguous" id="47" impl="NAMING-47" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-47.rule"/>
         </rule>
         <rule header="The \ character should not occur in a header file name" id="48" impl="NAMING-48" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-48.rule"/>
         </rule>
         <rule header="Implementation files in C++ will always have a file name extension of &quot;.cpp&quot;" id="49" impl="NAMING-49" quickfix="false" scope="line" severity="4">
            <file path="NAMING\NAMING-49.rule"/>
         </rule>
         <rule header="Identifiers in the same name space with overlapping visibility should be typographically unambiguous" id="50" impl="NAMING-50" quickfix="false" scope="line" severity="4">
            <file path="NAMING\NAMING-50.rule"/>
         </rule>
         <rule header="User defined suffixes of the user defined literal operators shall start with underscore followed by one or more letters" id="51" impl="NAMING-51" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-51.rule"/>
         </rule>
         <rule header="Universal character names shall be used only inside character or string literals" id="52" impl="NAMING-52" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-52.rule"/>
         </rule>
         <rule header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" id="53" impl="NAMING-53" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-53.rule"/>
         </rule>
         <category description="Hungarian Notation" name="HN">
            <rule header="Hungarian notation for array variables and parameters" id="01" impl="NAMING-HN-01" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-01.rule"/>
            </rule>
            <rule header="Hungarian notation for bool types" id="02" impl="NAMING-HN-02" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-02.rule"/>
            </rule>
            <rule header="Hungarian notation for bool pointer, array, or reference types" id="03" impl="NAMING-HN-03" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-03.rule"/>
            </rule>
            <rule header="Hungarian notation for byte types" id="04" impl="NAMING-HN-04" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-04.rule"/>
            </rule>
            <rule header="Hungarian notation for byte pointer, array, or reference types" id="05" impl="NAMING-HN-05" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-05.rule"/>
            </rule>
            <rule header="Hungarian notation for char types" id="06" impl="NAMING-HN-06" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-06.rule"/>
            </rule>
            <rule header="Hungarian notation for array of char types" id="07" impl="NAMING-HN-07" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-07.rule"/>
            </rule>
            <rule header="Hungarian notation for pointer, array, or reference to array of char types" id="08" impl="NAMING-HN-08" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-08.rule"/>
            </rule>
            <rule header="Hungarian notation for char pointer, array, or reference types" id="09" impl="NAMING-HN-09" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-09.rule"/>
            </rule>
            <rule header="Hungarian notation for char pointer or reference types" id="10" impl="NAMING-HN-10" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-10.rule"/>
            </rule>
            <rule header="Hungarian notation for constant parameters" id="11" impl="NAMING-HN-11" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-11.rule"/>
            </rule>
            <rule header="Hungarian notation for double-precision floating point types" id="12" impl="NAMING-HN-12" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-12.rule"/>
            </rule>
            <rule header="Hungarian notation for double-precision floating point pointer, array, or reference types" id="13" impl="NAMING-HN-13" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-13.rule"/>
            </rule>
            <rule header="Hungarian notation for dword types" id="14" impl="NAMING-HN-14" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-14.rule"/>
            </rule>
            <rule header="Hungarian notation for dword pointer, array, or reference types" id="15" impl="NAMING-HN-15" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-15.rule"/>
            </rule>
            <rule header="Hungarian notation for dynamically allocated array" id="16" impl="NAMING-HN-16" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-16.rule"/>
            </rule>
            <rule header="Hungarian notation for floating point types" id="17" impl="NAMING-HN-17" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-17.rule"/>
            </rule>
            <rule header="Hungarian notation for floating point pointer, array, or reference types" id="18" impl="NAMING-HN-18" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-18.rule"/>
            </rule>
            <rule header="Hungarian notation for class declaration" id="19" impl="NAMING-HN-19" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-19.rule"/>
            </rule>
            <rule header="Hungarian notation for structs declaration" id="20" impl="NAMING-HN-20" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-20.rule"/>
            </rule>
            <rule header="Hungarian notation for ifstream type variables and parameters" id="21" impl="NAMING-HN-21" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-21.rule"/>
            </rule>
            <rule header="Hungarian notation for int types" id="22" impl="NAMING-HN-22" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-22.rule"/>
            </rule>
            <rule header="Hungarian notation for int pointer, array, or reference types" id="23" impl="NAMING-HN-23" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-23.rule"/>
            </rule>
            <rule header="Hungarian notation for istream type parameters and variables" id="24" impl="NAMING-HN-24" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-24.rule"/>
            </rule>
            <rule header="Hungarian notation for long int types" id="25" impl="NAMING-HN-25" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-25.rule"/>
            </rule>
            <rule header="Hungarian notation for long double-precision floating point types" id="26" impl="NAMING-HN-26" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-26.rule"/>
            </rule>
            <rule header="Hungarian notation for long double-precision floating point pointer, array, or reference types" id="27" impl="NAMING-HN-27" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-27.rule"/>
            </rule>
            <rule header="Hungarian notation for long int pointer, array, or reference types" id="28" impl="NAMING-HN-28" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-28.rule"/>
            </rule>
            <rule header="Hungarian notation for member variables" id="29" impl="NAMING-HN-29" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-29.rule"/>
            </rule>
            <rule header="Hungarian notation for int types" id="30" impl="NAMING-HN-30" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-30.rule"/>
            </rule>
            <rule header="Hungarian notation for int pointer, array, or reference types" id="31" impl="NAMING-HN-31" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-31.rule"/>
            </rule>
            <rule header="Hungarian notation for ofstream type parameters and variables" id="32" impl="NAMING-HN-32" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-32.rule"/>
            </rule>
            <rule header="Hungarian notation for ostream type parameters and variables" id="33" impl="NAMING-HN-33" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-33.rule"/>
            </rule>
            <rule header="Hungarian notation for pointer" id="34" impl="NAMING-HN-34" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-34.rule"/>
            </rule>
            <rule header="Hungarian notation for reference parameters" id="35" impl="NAMING-HN-35" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-35.rule"/>
            </rule>
            <rule header="Hungarian notation for short int types" id="36" impl="NAMING-HN-36" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-36.rule"/>
            </rule>
            <rule header="Hungarian notation for short int pointer, array, or reference types" id="37" impl="NAMING-HN-37" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-37.rule"/>
            </rule>
            <rule header="Hungarian notation for static variables" id="38" impl="NAMING-HN-38" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-38.rule"/>
            </rule>
            <rule header="Hungarian notation for string types" id="39" impl="NAMING-HN-39" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-39.rule"/>
            </rule>
            <rule header="Hungarian notation for string pointer, array, or reference types" id="40" impl="NAMING-HN-40" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-40.rule"/>
            </rule>
            <rule header="Hungarian notation for unsigned types" id="41" impl="NAMING-HN-41" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-41.rule"/>
            </rule>
            <rule header="Hungarian notation for void pointer types" id="42" impl="NAMING-HN-42" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-42.rule"/>
            </rule>
            <rule header="Hungarian notation for word types" id="43" impl="NAMING-HN-43" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-43.rule"/>
            </rule>
            <rule header="Hungarian notation for word pointer, array, or reference types" id="44" impl="NAMING-HN-44" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-44.rule"/>
            </rule>
         </category>
      </category>
      <category description="Object Oriented" name="OOP">
         <rule header="Avoid public copy constructors and assignment operators in base classes" id="01" impl="OOP-01" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-01.rule"/>
         </rule>
         <rule header="Avoid slicing. Consider Clone instead of copying in base classes" id="02" impl="OOP-02" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-02.rule"/>
         </rule>
         <rule header="Class cannot inherit other class more than once unless it is virtual inheritance" id="03" impl="OOP-03" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-03.rule"/>
         </rule>
         <rule header="Do not derive functions with the same name from more than one base class" id="04" impl="OOP-04" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-04.rule"/>
         </rule>
         <rule header="Do not use multiple inheritance" id="05" impl="OOP-05" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-05.rule"/>
         </rule>
         <rule header="For multiple inheritance use virtual common base class" id="06" impl="OOP-06" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-06.rule"/>
         </rule>
         <rule header="Be wary about using multiple inheritance of classes that are not abstract interfaces" id="07" impl="OOP-07" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-07.rule"/>
         </rule>
         <rule header="Multiple inheritance shall be limited to at most 1 protected implementation" id="07_a" impl="OOP-07_a" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-07_a.rule"/>
         </rule>
         <rule header="Multiple inheritance shall not use any public implementations" id="07_b" impl="OOP-07_b" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-07_b.rule"/>
         </rule>
         <rule header="Do not directly access global data from a constructor" id="08" impl="OOP-08" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-08.rule"/>
         </rule>
         <rule header="Avoid the use of global objects in destructors" id="09" impl="OOP-09" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-09.rule"/>
         </rule>
         <rule header="Avoid using global data in member functions" id="10" impl="OOP-10" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-10.rule"/>
         </rule>
         <rule header="Avoid using the friend mechanism" id="11" impl="OOP-11" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-11.rule"/>
         </rule>
         <rule header="Protected member function shall not return non-const handles to private class-data" id="12" impl="OOP-12" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-12.rule"/>
         </rule>
         <rule header="Do not redefine an inherited virtual function with a different default parameter value" id="13" impl="OOP-13" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-13.rule"/>
         </rule>
         <rule header="Consider use composition instead of private inheritance" id="14" impl="OOP-14" quickfix="false" scope="line" severity="5">
            <file path="OOP\OOP-14.rule"/>
         </rule>
         <rule header="Avoid calling virtual functions from constructors" id="16" impl="OOP-16" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-16.rule"/>
         </rule>
         <rule header="Avoid calling virtual functions from destructors" id="16_b" impl="OOP-16_b" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-16_b.rule"/>
         </rule>
         <rule header="Write a using declaration to redeclare overloaded functions" id="17" impl="OOP-17" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-17.rule"/>
         </rule>
         <rule header="Avoid &quot;public&quot; data members" id="18" impl="OOP-18" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-18.rule"/>
         </rule>
         <rule header="Avoid 'protected' data members" id="19" impl="OOP-19" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-19.rule"/>
         </rule>
         <rule header="Avoid explicit cast from derived to a base class" id="20" impl="OOP-20" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-20.rule"/>
         </rule>
         <rule header="Use the virtual keyword if a subclass implements a virtual function" id="21" impl="OOP-21" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-21.rule"/>
         </rule>
         <rule header="Define a virtual destructor in classes used as base classes which have virtual functions" id="22" impl="OOP-22" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-22.rule"/>
         </rule>
         <rule header="If a class has virtual functions it shall have a virtual destructor" id="23" impl="OOP-23" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-23.rule"/>
         </rule>
         <rule header="Make destructors virtual in base classes" id="24" impl="OOP-24" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-24.rule"/>
         </rule>
         <rule header="Avoid declaring virtual functions inline" id="25" impl="OOP-25" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-25.rule"/>
         </rule>
         <rule header="Never convert pointers to objects of a derived class to pointers to objects of a virtual base class" id="26" impl="OOP-26" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-26.rule"/>
         </rule>
         <rule header="Declare copy assignment operator for class with reference or const members" id="27" impl="OOP-27" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-27.rule"/>
         </rule>
         <rule header="Avoid casts down the inheritance hierarchy" id="28" impl="OOP-28" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-28.rule"/>
         </rule>
         <rule header="A pointer to an abstract class shall not be converted to a pointer of a class that inherits from that abstract class" id="29" impl="OOP-29" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-29.rule"/>
         </rule>
         <rule header="Declare the copy constructor and copy assignment operator private not in class itself, but in a specifically designed base class" id="30" impl="OOP-30" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-30.rule"/>
         </rule>
         <rule header="Make base class destructors public and virtual, or protected and nonvirtual" id="31" impl="OOP-31" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-31.rule"/>
         </rule>
         <rule header="Never redefine an inherited nonvirtual function" id="32" impl="OOP-32" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-32.rule"/>
         </rule>
         <rule header="Do not redefine an inherited nonvirtual function with template parameter" id="33" impl="OOP-33" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-33.rule"/>
         </rule>
         <rule header="Check for assignment to self in operator=" id="34" impl="OOP-34" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-34.rule"/>
         </rule>
         <rule header="Down casting (casting from base to derived class) shall not be allowed" id="35" impl="OOP-35" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-35.rule"/>
         </rule>
         <rule header="Public member functions shall not return non-const handles to private/protected class-data" id="36" impl="OOP-36" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-36.rule"/>
         </rule>
         <rule header="Prefer composition when don't need inheritance" id="37" impl="OOP-37" quickfix="false" scope="line" severity="5">
            <file path="OOP\OOP-37.rule"/>
         </rule>
         <rule header="If a class destructor is called and the class has virtual functions it shall have a virtual destructor" id="38" impl="OOP-38" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-38.rule"/>
         </rule>
         <rule header="A virtual base shall be explicitly declared in each derived class" id="39" impl="OOP-39" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-39.rule"/>
         </rule>
         <rule header="A stateful virtual base shall be explicitly declared in each derived class that accesses it" id="39_b" impl="OOP-39_b" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-39_b.rule"/>
         </rule>
         <rule header="Hierarchies should be based on abstract classes" id="40" impl="OOP-40" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-40.rule"/>
         </rule>
         <rule header="A base class shall not be both virtual and non-virtual in the same hierarchy" id="41" impl="OOP-41" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-41.rule"/>
         </rule>
         <rule header="The copy assignment operator shall be declared protected or private in an abstract class" id="42" impl="OOP-42" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-42.rule"/>
         </rule>
         <rule header="A virtual function shall only be overridden by a pure virtual function if it is itself declared as pure virtual" id="43" impl="OOP-43" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-43.rule"/>
         </rule>
         <rule header="There shall be no more than one definition of each virtual function on each path through the inheritance hierarchy" id="44" impl="OOP-44" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-44.rule"/>
         </rule>
         <rule header="All constructors that are callable with a single argument of fundamental type shall be declared explicit" id="45" impl="OOP-45" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-45.rule"/>
         </rule>
         <rule header="A copy constructor shall only initialize its base classes and the non-static members of the class of which it is a member" id="46" impl="OOP-46" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-46.rule"/>
         </rule>
         <rule header="Classes should not be derived from virtual bases" id="47" impl="OOP-47" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-47.rule"/>
         </rule>
         <rule header="Member data in non-POD types shall be private" id="48" impl="OOP-48" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-48.rule"/>
         </rule>
         <rule header="Casts from a base class to a derived class should not be performed on polymorphic types" id="49" impl="OOP-49" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-49.rule"/>
         </rule>
         <rule header="A pointer to a virtual base class shall only be cast to a pointer to a derived class by means of dynamic_cast" id="50" impl="OOP-50" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-50.rule"/>
         </rule>
         <rule header="Use namespace instead of class or structure containing only static functions" id="51" impl="OOP-51" quickfix="false" scope="line" severity="5">
            <file path="OOP\OOP-51.rule"/>
         </rule>
         <rule header="A pointer to a class may not be converted to a pointer of a second class unless the one inherits from the other" id="52" impl="OOP-52" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-52.rule"/>
         </rule>
         <rule header="Member functions declared in derived class should not hide functions declared in base classes" id="53" impl="OOP-53" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-53.rule"/>
         </rule>
         <rule header="Do not increase the accessibility of overridden or hidden methods" id="54" impl="OOP-54" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-54.rule"/>
         </rule>
         <rule header="A non-POD type should be defined as class" id="55" impl="OOP-55" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-55.rule"/>
         </rule>
         <rule header="A user-defined assignment operator shall not be virtual" id="56" impl="OOP-56" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-56.rule"/>
         </rule>
         <rule header="Structs should only contain public data members and should not be a base or inherit" id="57" impl="OOP-57" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-57.rule"/>
         </rule>
      </category>
      <category description="Optimization" name="OPT">
         <rule header="Declare variables as locally as possible" id="01" impl="OPT-01" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-01.rule"/>
         </rule>
         <rule header="Avoid unused local variables" id="02" impl="OPT-02" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-02.rule"/>
         </rule>
         <rule header="Eliminate unused parameters" id="03" impl="OPT-03" quickfix="false" scope="line" severity="2">
            <file path="OPT\OPT-03.rule"/>
         </rule>
         <rule header="Prefer canonical form of ++ and --. Prefer calling the prefix forms" id="04" impl="OPT-04" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-04.rule"/>
         </rule>
         <rule header="Eliminate unused private member variables" id="05" impl="OPT-05" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-05.rule"/>
         </rule>
         <rule header="Avoid unnecessary local variables" id="06" impl="OPT-06" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-06.rule"/>
         </rule>
         <rule header="Prefer &quot;a @= b&quot; than &quot;a = a @ b&quot;, where &quot;@&quot; is +, -, *, /, %" id="07" impl="OPT-07" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-07.rule"/>
         </rule>
         <rule header="Prefer &quot;a @= b&quot; than &quot;a = a @ b&quot;, where &quot;@&quot; is &amp;, |, ^, &lt;&lt;, &gt;&gt;" id="08" impl="OPT-08" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-08.rule"/>
         </rule>
         <rule header="Remove unnecessary '== true'" id="09" impl="OPT-09" quickfix="false" scope="line" severity="5">
            <file path="OPT\OPT-09.rule"/>
         </rule>
         <rule header="Do not declare variables in &quot;if&quot;, &quot;for&quot;, &quot;while&quot;, and &quot;do while&quot; statement" id="10" impl="OPT-10" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-10.rule"/>
         </rule>
         <rule header="If a file-level static variable is used/referenced in one function only then include that variable in the function itself" id="11" impl="OPT-11" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-11.rule"/>
         </rule>
         <rule header="If a file-level static variable is used/referenced in one class only then include that variable in the class itself" id="12" impl="OPT-12" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-12.rule"/>
         </rule>
         <rule header="Declare member variables in the descending size order" id="13" impl="OPT-13" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-13.rule"/>
         </rule>
         <rule header="Pass objects by reference instead of by value" id="14" impl="OPT-14" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-14.rule"/>
         </rule>
         <rule header="Consider overloading to avoid implicit type conversions" id="15" impl="OPT-15" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-15.rule"/>
         </rule>
         <rule header="Global function containing recursion, loops or virtual function call should not be inlined" id="16" impl="OPT-16" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-16.rule"/>
         </rule>
         <rule header="Avoid inline constructors and destructors" id="17" impl="OPT-17" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-17.rule"/>
         </rule>
         <rule header="Member function containing recursion or loops should not be inlined" id="18" impl="OPT-18" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-18.rule"/>
         </rule>
         <rule header="Consider using op= instead of stand-alone op" id="19" impl="OPT-19" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-19.rule"/>
         </rule>
         <rule header="Postpone variable definitions as long as possible" id="20" impl="OPT-20" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-20.rule"/>
         </rule>
         <rule header="Every switch statement shall have at least one non-empty case clause" id="21" impl="OPT-21" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-21.rule"/>
         </rule>
         <rule header="Useless case statement shall not be permitted" id="22" impl="OPT-22" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-22.rule"/>
         </rule>
         <rule header="Trivial accessor and mutator functions should be inlined" id="23" impl="OPT-23" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-23.rule"/>
         </rule>
         <rule header="Trivial forwarding functions should be inlined" id="24" impl="OPT-24" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-24.rule"/>
         </rule>
         <rule header="Only functions with 1 or 2 statements should be considered candidates for inline functions" id="25" impl="OPT-25" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-25.rule"/>
         </rule>
         <rule header="Variables will not be introduced until they can be initialized with meaningful values" id="26" impl="OPT-26" quickfix="false" scope="line" severity="2">
            <file path="OPT\OPT-26.rule"/>
         </rule>
         <rule header="The number of accessor and mutator functions should be minimized" id="27" impl="OPT-27" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-27.rule"/>
         </rule>
         <rule header="'strlen' function should not be used to check string against NULL/non-NULL" id="28" impl="OPT-28" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-28.rule"/>
         </rule>
         <rule header="Redundant explicit cast to the same type is not allowed" id="29" impl="OPT-29" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-29.rule"/>
         </rule>
         <rule header="Every defined function with internal linkage shall be used at least once" id="30" impl="OPT-30" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-30.rule"/>
         </rule>
         <rule header="There shall be no unused parameters (named or unnamed) in non-virtual functions" id="31" impl="OPT-31" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-31.rule"/>
         </rule>
         <rule header="All non-empty functions with void return type shall have external side effect(s)" id="32" impl="OPT-32" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-32.rule"/>
         </rule>
         <rule header="Functions with void return type shall not be empty" id="32_b" impl="OPT-32_b" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-32_b.rule"/>
         </rule>
         <rule header="Consider returning object by reference instead of by value" id="33" impl="OPT-33" quickfix="false" scope="line" severity="5">
            <file path="OPT\OPT-33.rule"/>
         </rule>
         <rule header="Do not assign a variable to itself" id="35" impl="OPT-35" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-35.rule"/>
         </rule>
         <rule header="Do not use a variable inside its own initializer" id="36" impl="OPT-36" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-36.rule"/>
         </rule>
         <rule header="A function should not contain unused label declarations" id="37" impl="OPT-37" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-37.rule"/>
         </rule>
         <rule header="There should be no unused parameters in functions" id="38" impl="OPT-38" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-38.rule"/>
         </rule>
         <rule header="Every switch statement shall have at least two switch-clauses" id="39" impl="OPT-39" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-39.rule"/>
         </rule>
         <rule header="The same code (after preprocessing) in two branches of if-else-if chain" id="40_a" impl="OPT-40_a" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-40_a.rule"/>
         </rule>
         <rule header="The same code (after preprocessing) in different clauses of switch statement" id="40_b" impl="OPT-40_b" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-40_b.rule"/>
         </rule>
         <rule header="A file should directly include only the headers that contain declarations and definitions required to compile that file" id="41" impl="OPT-41" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-41.rule"/>
         </rule>
      </category>
      <category description="Possible Bugs" name="PB">
         <rule header="Do not dereference pointer type expressions" id="01" impl="PB-01" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-01.rule"/>
         </rule>
         <rule header="Do not use assignments inside a(b), a[b], and cast" id="02" impl="PB-02" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-02.rule"/>
         </rule>
         <rule header="Using mixed types in ternary operator is not allowed" id="03" impl="PB-03" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-03.rule"/>
         </rule>
         <rule header="Return value of a function must match declared return type" id="05" impl="PB-05" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-05.rule"/>
         </rule>
         <rule header="Assignment operator should have operands of compatible types" id="06" impl="PB-06" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-06.rule"/>
         </rule>
         <rule header="Do not assign function return value to a variable of incompatible type" id="07" impl="PB-07" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-07.rule"/>
         </rule>
         <rule header="Do not assign signed constants to unsigned integer variables" id="08" impl="PB-08" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-08.rule"/>
         </rule>
         <rule header="Operators should not return value by reference" id="09" impl="PB-09" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-09.rule"/>
         </rule>
         <rule header="Don't treat arrays polymorphically" id="10" impl="PB-10" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-10.rule"/>
         </rule>
         <rule header="Declared types of formal and actual parameters to functions must match" id="11" impl="PB-11" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-11.rule"/>
         </rule>
         <rule header="Do not cast a signed char to an unsigned int" id="12" impl="PB-12" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-12.rule"/>
         </rule>
         <rule header="Do not call delete on non-pointers" id="13" impl="PB-13" quickfix="false" scope="line" severity="1">
            <file path="PB\PB-13.rule"/>
         </rule>
         <rule header="Incorrect End-Of-String (EOS) definition" id="14" impl="PB-14" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-14.rule"/>
         </rule>
         <rule header="Don't assign the dividend of two integers to a floating-point type" id="15" impl="PB-15" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-15.rule"/>
         </rule>
         <rule header="Avoid unintentionally discarding the remainder of integer division" id="15_b" impl="PB-15_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-15_b.rule"/>
         </rule>
         <rule header="Avoid assigning out-of-range value to char type" id="16" impl="PB-16" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-16.rule"/>
         </rule>
         <rule header="Avoid assigning out-of-range value to unsigned char type" id="17" impl="PB-17" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-17.rule"/>
         </rule>
         <rule header="Avoid overloading class methods on a pointer and a numerical type" id="18" impl="PB-18" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-18.rule"/>
         </rule>
         <rule header="Do not create inline non-member functions that contain local static data" id="19" impl="PB-19" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-19.rule"/>
         </rule>
         <rule header="Avoid slicing function arguments / return value" id="20" impl="PB-20" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-20.rule"/>
         </rule>
         <rule header="Properly terminate character strings" id="21" impl="PB-21" quickfix="false" scope="line" severity="1">
            <file path="PB\PB-21.rule"/>
         </rule>
         <rule header="Do not use increment and decrement expressions inside a(b), a[b], and cast" id="22" impl="PB-22" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-22.rule"/>
         </rule>
         <rule header="The class object should be passed by reference if the class has non-static pointers and has no declared copy constructor" id="23" impl="PB-23" quickfix="false" scope="line" severity="1">
            <file path="PB\PB-23.rule"/>
         </rule>
         <rule header="The definition of a constructor shall not contain default arguments that produce a signature identical to that of the implicitly-declared copy constructor" id="24" impl="PB-24" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-24.rule"/>
         </rule>
         <rule header="Unsigned arithmetic shall not be used" id="25" impl="PB-25" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-25.rule"/>
         </rule>
         <rule header="Public and protected methods should not be invoked by class constructor" id="26" impl="PB-26" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-26.rule"/>
         </rule>
         <rule header="A string literal shall not be modified" id="27" impl="PB-27" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-27.rule"/>
         </rule>
         <rule header="The following character sequences shall not appear in header file names: ', \, /*, //, or &quot;" id="28" impl="PB-28" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-28.rule"/>
         </rule>
         <rule header="The left-hand operand of a right-shift operator shall not have a negative value" id="29" impl="PB-29" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-29.rule"/>
         </rule>
         <rule header="More than one 'enum' type shall not be used as a switch condition or a label in a case statement" id="30" impl="PB-30" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-30.rule"/>
         </rule>
         <rule header="Do not call 'sizeof' on constants" id="31" impl="PB-31" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-31.rule"/>
         </rule>
         <rule header="Do not call 'sizeof' on a pointer type" id="32" impl="PB-32" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-32.rule"/>
         </rule>
         <rule header="Avoid implicit type conversions in assignments involving enum types" id="33" impl="PB-33" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-33.rule"/>
         </rule>
         <rule header="Avoid implicit type conversions in comparisons involving enum types" id="33_b" impl="PB-33_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-33_b.rule"/>
         </rule>
         <rule header="Third parameter to 'memcpy'/'strncpy'/'memmove' should not depend on second" id="34" impl="PB-34" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-34.rule"/>
         </rule>
         <rule header="Assignment operators shall not be used in conditions without brackets" id="35" impl="PB-35" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-35.rule"/>
         </rule>
         <rule header="An object's dynamic type shall not be used from the body of its constructor or destructor" id="36" impl="PB-36" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-36.rule"/>
         </rule>
         <rule header="The unbounded functions of library &lt;cstring&gt; shall not be used" id="37" impl="PB-37" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-37.rule"/>
         </rule>
         <rule header="Narrow and wide string literals shall not be concatenated" id="38" impl="PB-38" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-38.rule"/>
         </rule>
         <rule header="String literals with different encoding prefixes shall not be concatenated" id="38_b" impl="PB-38_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-38_b.rule"/>
         </rule>
         <rule header="A function shall not return a reference or a pointer to a parameter that is passed by reference or const reference" id="39" impl="PB-39" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-39.rule"/>
         </rule>
         <rule header="A function shall not return a pointer or a reference to a parameter that is passed by const reference" id="39_b" impl="PB-39_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-39_b.rule"/>
         </rule>
         <rule header="An identifier with array type passed as a function argument shall not decay to a pointer" id="41" impl="PB-41" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-41.rule"/>
         </rule>
         <rule header="Do not pass expression with array type to a function with pointer or array type parameter" id="41_b" impl="PB-41_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-41_b.rule"/>
         </rule>
         <rule header="An object shall not be assigned to an overlapping object" id="42" impl="PB-42" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-42.rule"/>
         </rule>
         <rule header="All constructors of a class should explicitly call a constructor for all of its immediate base classes and all virtual base classes" id="43" impl="PB-43" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-43.rule"/>
         </rule>
         <rule header="The execution of a function registered with 'std::atexit()' or 'std::at_quick_exit()' should not exit via an exception" id="44" impl="PB-44" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-44.rule"/>
         </rule>
         <rule header="There should be no mismatch between the '%s' and '%c' format specifiers in the format string and their corresponding arguments in the invocation of a string formatting function" id="45" impl="PB-45" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-45.rule"/>
         </rule>
         <rule header="There should be no mismatch between the '%f' format specifier in the format string and its corresponding argument in the invocation of a string formatting function" id="46" impl="PB-46" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-46.rule"/>
         </rule>
         <rule header="There should be no mismatch between the '%i' and '%d' format specifiers in the string and their corresponding arguments in the invocation of a string formatting function" id="47" impl="PB-47" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-47.rule"/>
         </rule>
         <rule header="There should be no mismatch between the '%u' format specifier in the format string and its corresponding argument in the invocation of a string formatting function" id="48" impl="PB-48" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-48.rule"/>
         </rule>
         <rule header="There should be no mismatch between the '%p' format specifier in the format string and its corresponding argument in the invocation of a string formatting function" id="49" impl="PB-49" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-49.rule"/>
         </rule>
         <rule header="The number of format specifiers in the format string and the number of corresponding arguments in the invocation of a string formatting function should be equal" id="50" impl="PB-50" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-50.rule"/>
         </rule>
         <rule header="Pointer arithmetic shall not be applied to pointers that address variables of non-array type" id="51" impl="PB-51" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-51.rule"/>
         </rule>
         <rule header="Avoid overloading global functions on a pointer and a numerical type" id="52" impl="PB-52" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-52.rule"/>
         </rule>
         <rule header="Avoid overloading namespace functions on a pointer and a numerical type" id="53" impl="PB-53" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-53.rule"/>
         </rule>
         <rule header="Do not cast from or to incomplete class at the point of casting" id="54" impl="PB-54" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-54.rule"/>
         </rule>
         <rule header="Do not delete objects with incomplete class at the point of deletion" id="55" impl="PB-55" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-55.rule"/>
         </rule>
         <rule header="Avoid implicit conversions from signed to unsigned type" id="56" impl="PB-56" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-56.rule"/>
         </rule>
         <rule header="A pointer to an array of derived class objects should not be converted to a base class pointer" id="57" impl="PB-57" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-57.rule"/>
         </rule>
         <rule header="Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique" id="58" impl="PB-58" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-58.rule"/>
         </rule>
         <rule header="Missing comma in a string array initialization" id="59" impl="PB-59" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-59.rule"/>
         </rule>
         <rule header="Suspicious argument to malloc" id="60" impl="PB-60" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-60.rule"/>
         </rule>
         <rule header="Pointer arithmetic performed on freshly allocated memory" id="61" impl="PB-61" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-61.rule"/>
         </rule>
         <rule header="Avoid function calls with incorrect argument order" id="62" impl="PB-62" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-62.rule"/>
         </rule>
         <rule header="Function address should not be compared to zero" id="63" impl="PB-63" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-63.rule"/>
         </rule>
         <rule header="The values returned by string comparison functions should be compared only to zero" id="64" impl="PB-64" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-64.rule"/>
         </rule>
         <rule header="Avoid possible integer overflow in expressions in which the result is assigned to a variable of a wider integer type" id="65" impl="PB-65" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-65.rule"/>
         </rule>
         <rule header="Avoid possible integer overflow in expressions in which the result is compared to an expression of a wider integer type" id="65_b" impl="PB-65_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-65_b.rule"/>
         </rule>
         <rule header="Integer overflow or underflow in constant expression in '+', '-', '*' operator" id="66_a" impl="PB-66_a" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-66_a.rule"/>
         </rule>
         <rule header="Integer overflow or underflow in constant expression in '&lt;&lt;' operator" id="66_b" impl="PB-66_b" quickfix="false" scope="line" severity="4">
            <file path="PB\PB-66_b.rule"/>
         </rule>
         <rule header="The same code (after preprocessing) in both branches of if-else statement" id="67" impl="PB-67" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-67.rule"/>
         </rule>
         <rule header="Boolean condition always evaluates to the same value due to enumeration with only zero or only non-zero constants" id="68" impl="PB-68" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-68.rule"/>
         </rule>
         <rule header="An element of an object shall not be initialized more than once" id="69" impl="PB-69" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-69.rule"/>
         </rule>
         <rule header="An expression with enum underlying type shall only have values corresponding to the enumerators of the enumeration" id="70" impl="PB-70" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-70.rule"/>
         </rule>
         <rule header="Do not copy instances of structures containing a flexible array member" id="71" impl="PB-71" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-71.rule"/>
         </rule>
         <rule header="Do not call va_arg with an argument of the incorrect type" id="72" impl="PB-72" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-72.rule"/>
         </rule>
         <rule header="Evaluation of constant unsigned integer expressions should not lead to wrap-around" id="73" impl="PB-73" quickfix="false" scope="line" severity="5">
            <file path="PB\PB-73.rule"/>
         </rule>
         <rule header="Do not add or subtract a constant with a value greater than one from an iterator" id="74" impl="PB-74" quickfix="false" scope="line" severity="4">
            <file path="PB\PB-74.rule"/>
         </rule>
         <rule header="The library functions 'abort()', 'quick_exit()' and '_Exit()' from 'cstdlib' library shall not be used" id="75" impl="PB-75" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-75.rule"/>
         </rule>
      </category>
      <category description="Physical File Organization" name="PFO">
         <rule header="Don't define entities with linkage in a header file" id="01" impl="PFO-01" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-01.rule"/>
         </rule>
         <rule header="Use multiple include guards" id="02" impl="PFO-02" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-02.rule"/>
         </rule>
         <rule header="An include file should not contain more than one class definition" id="03" impl="PFO-03" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-03.rule"/>
         </rule>
         <rule header="Every implementation file should declare a local constant string that describes the file" id="04" impl="PFO-04" quickfix="false" scope="line" severity="5">
            <file path="PFO\PFO-04.rule"/>
         </rule>
         <rule header="File with extension '.c' may not include other files with extension '.c'" id="05" impl="PFO-05" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-05.rule"/>
         </rule>
         <rule header="Never include other files in a file with extension '.icc'" id="06" impl="PFO-06" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-06.rule"/>
         </rule>
         <rule header="Use multiple include guards with pattern based on the header file name" id="07" impl="PFO-07" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-07.rule"/>
         </rule>
         <rule header="Use mechanism that prevents multiple inclusion of the file i.e. include guards or &quot;#pragma once&quot; preprocessor directive" id="08" impl="PFO-08" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-08.rule"/>
         </rule>
         <rule header="&quot;#pragma once&quot; preprocessor directive should not be used in source files" id="09" impl="PFO-09" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-09.rule"/>
         </rule>
      </category>
      <category description="Portability" name="PORT">
         <rule header="Use capital 'L' instead of lowercase 'l' to indicate long" id="01" impl="PORT-01" quickfix="false" scope="line" severity="5">
            <file path="PORT\PORT-01.rule"/>
         </rule>
         <rule header="Assigning result of ints operation to long without casting at least one of the ints is not allowed" id="02" impl="PORT-02" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-02.rule"/>
         </rule>
         <rule header="Don't use hard coded value of offset in structures" id="03" impl="PORT-03" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-03.rule"/>
         </rule>
         <rule header="Don't use hex constant '0xffffffff' as an error marker" id="04" impl="PORT-04" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-04.rule"/>
         </rule>
         <rule header="A pointer to a long should not be casted to an int pointer" id="05" impl="PORT-05" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-05.rule"/>
         </rule>
         <rule header="Do not assign a long int to an int" id="06" impl="PORT-06" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-06.rule"/>
         </rule>
         <rule header="Do not pass long casted to an int in function call" id="07" impl="PORT-07" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-07.rule"/>
         </rule>
         <rule header="Constant assignment to long should not involve int literals" id="08" impl="PORT-08" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-08.rule"/>
         </rule>
         <rule header="Do not initialize a long int with int literals" id="10" impl="PORT-10" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-10.rule"/>
         </rule>
         <rule header="Do not cast an int pointer to a long pointer" id="11" impl="PORT-11" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-11.rule"/>
         </rule>
         <rule header="Do not assign the value from 32 bit multiplication to long type" id="12" impl="PORT-12" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-12.rule"/>
         </rule>
         <rule header="The type int shall always be declared as unsigned int or signed int" id="13" impl="PORT-13" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-13.rule"/>
         </rule>
         <rule header="Avoid conversions from &quot;shorter&quot; type to &quot;longer&quot; type in assignment" id="14" impl="PORT-14" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-14.rule"/>
         </rule>
         <rule header="Do not cast from &quot;shorter&quot; type to &quot;longer&quot; type" id="15" impl="PORT-15" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-15.rule"/>
         </rule>
         <rule header="Avoid conversions from a &quot;shorter&quot; type to a &quot;longer&quot; type in function calls" id="16" impl="PORT-16" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-16.rule"/>
         </rule>
         <rule header="Don't use 'i64' or 'L' suffixes directly" id="17" impl="PORT-17" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-17.rule"/>
         </rule>
         <rule header="Instead of casting a long type operand of an expression to int cast the result of the expression" id="19" impl="PORT-19" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-19.rule"/>
         </rule>
         <rule header="Do not declare variables of long type directly" id="20" impl="PORT-20" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-20.rule"/>
         </rule>
         <rule header="Do not assign a long value to a double" id="21" impl="PORT-21" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-21.rule"/>
         </rule>
         <rule header="Use arrays of int types instead of large arrays of longs" id="22" impl="PORT-22" quickfix="false" scope="line" severity="5">
            <file path="PORT\PORT-22.rule"/>
         </rule>
         <rule header="Use arrays of int types instead of dynamic allocated large arrays of longs" id="23" impl="PORT-23" quickfix="false" scope="line" severity="5">
            <file path="PORT\PORT-23.rule"/>
         </rule>
         <rule header="Don't use large arrays of pointers to bool, char, short, int and float types" id="24" impl="PORT-24" quickfix="false" scope="line" severity="5">
            <file path="PORT\PORT-24.rule"/>
         </rule>
         <rule header="User-specified identifiers (internal and external) will not rely on significance of more than 64 characters" id="25" impl="PORT-25" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-25.rule"/>
         </rule>
         <rule header="Algorithms shall not make assumptions concerning the order of allocation of nonstatic data members separated by an access specifier" id="26" impl="PORT-26" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-26.rule"/>
         </rule>
         <rule header="Avoid implicit conversions to a type of narrower size" id="27" impl="PORT-27" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-27.rule"/>
         </rule>
         <rule header="Avoid conversions of constant values to a narrower type" id="28" impl="PORT-28" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-28.rule"/>
         </rule>
         <rule header="A pointer to a structure should not be passed to a function that writes data to a file" id="29" impl="PORT-29" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-29.rule"/>
         </rule>
         <rule header="Do not throw an exception across execution boundaries" id="30" impl="PORT-30" quickfix="false" scope="line" severity="4">
            <file path="PORT\PORT-30.rule"/>
         </rule>
         <rule header="Do not pass a nonstandard-layout type object across execution boundaries" id="31" impl="PORT-31" quickfix="false" scope="line" severity="4">
            <file path="PORT\PORT-31.rule"/>
         </rule>
         <rule header="Type long double shall not be used" id="32" impl="PORT-32" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-32.rule"/>
         </rule>
         <rule header="Type wchar_t shall not be used" id="33" impl="PORT-33" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-33.rule"/>
         </rule>
      </category>
      <category description="Preprocessor" name="PREPROC">
         <rule header="Avoid macros" id="01" impl="PREPROC-01" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-01.rule"/>
         </rule>
         <rule header="Don't use macros in include statement" id="02" impl="PREPROC-02" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-02.rule"/>
         </rule>
         <rule header="Don't redefine primitive types" id="03" impl="PREPROC-03" quickfix="false" scope="line" severity="4">
            <file path="PREPROC\PREPROC-03.rule"/>
         </rule>
         <rule header="Don't define part of statement" id="04" impl="PREPROC-04" quickfix="false" scope="line" severity="4">
            <file path="PREPROC\PREPROC-04.rule"/>
         </rule>
         <rule header="In a macro function, use parentheses before and after multiplication or division" id="05" impl="PREPROC-05" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-05.rule"/>
         </rule>
         <rule header="Do not allow relative path names in #include statements" id="06" impl="PREPROC-06" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-06.rule"/>
         </rule>
         <rule header="Incorrect 'NULL' definition" id="07" impl="PREPROC-07" quickfix="false" scope="line" severity="5">
            <file path="PREPROC\PREPROC-07.rule"/>
         </rule>
         <rule header="The #include pre-processor directive will only be used to include header (*.h) files" id="08" impl="PREPROC-08" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-08.rule"/>
         </rule>
         <rule header="The #include directive shall use the &lt;filename.h&gt; notation to include header files" id="09" impl="PREPROC-09" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-09.rule"/>
         </rule>
         <rule header="The #ifndef and #endif pre-processor directives will only be used to prevent multiple inclusions of the same header file" id="10" impl="PREPROC-10" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-10.rule"/>
         </rule>
         <rule header="Only the following pre-processor directives shall be used: #ifndef, #define, #endif, #include" id="11" impl="PREPROC-11" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-11.rule"/>
         </rule>
         <rule header="C++ macros shall only be used for include guards, type qualifiers, or storage class specifiers" id="12" impl="PREPROC-12" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-12.rule"/>
         </rule>
         <rule header="Macro should not contain token pasting, variable argument list nor recursive macro calls" id="13" impl="PREPROC-13" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-13.rule"/>
         </rule>
         <rule header="All macros must expand into complete syntactic units" id="14" impl="PREPROC-14" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-14.rule"/>
         </rule>
         <rule header="Pointer dereference operations may not be hidden in macro definitions" id="15" impl="PREPROC-15" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-15.rule"/>
         </rule>
         <rule header="A macro parameter immediately following a # operator shall not immediately be followed by or preceded by a ## operator" id="16" impl="PREPROC-16" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-16.rule"/>
         </rule>
         <rule header="A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators" id="17" impl="PREPROC-17" quickfix="false" scope="line" severity="4">
            <file path="PREPROC\PREPROC-17.rule"/>
         </rule>
         <rule header="The input/output library stdio.h shall not be included" id="18" impl="PREPROC-18" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-18.rule"/>
         </rule>
         <rule header="The controlling expression of a #if or #elif preprocessing directive shall evaluate to 0 or 1" id="19" impl="PREPROC-19" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-19.rule"/>
         </rule>
         <rule header="Match the filename in a #include directive to the one on the filesystem" id="20" impl="PREPROC-20" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-20.rule"/>
         </rule>
         <rule header="Avoid token concatenation that may produce universal character names" id="21" impl="PREPROC-21" quickfix="false" scope="line" severity="5">
            <file path="PREPROC\PREPROC-21.rule"/>
         </rule>
         <rule header="#error directive shall not be used" id="22" impl="PREPROC-22" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-22.rule"/>
         </rule>
         <rule header="The #pragma directive shall not be used" id="23" impl="PREPROC-23" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-23.rule"/>
         </rule>
         <rule header="All macro identifiers in preprocessor directives shall be defined before use, except in #ifdef and #ifndef preprocessor directives and the defined() operator" id="24" impl="PREPROC-24" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-24.rule"/>
         </rule>
      </category>
      <category description="Qt Best Practices" name="QT">
         <rule header="Every QObject subclass should contain a Q_OBJECT macro" id="01" impl="QT-01" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-01.rule"/>
         </rule>
         <rule header="QObject must not be inherited more than one time" id="02" impl="QT-02" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-02.rule"/>
         </rule>
         <rule header="It's only possible to connect a signal to a slot or a signal to another signal" id="03" impl="QT-03" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-03.rule"/>
         </rule>
         <rule header="The methods inside the SIGNAL and SLOT macros have to exist" id="04" impl="QT-04" quickfix="false" scope="line" severity="1">
            <file path="QT\QT-04.rule"/>
         </rule>
         <rule header="Mark signal emissions with the keyword &quot;emit&quot; to distinguish a signal emission from a normal method call" id="05" impl="QT-05" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-05.rule"/>
         </rule>
         <rule header="Do not set Idle or Critical priority to QThreads. Use High/Low/Med only" id="06" impl="QT-06" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-06.rule"/>
         </rule>
         <rule header="Do not force thread termination by calling QThread::terminate()" id="07" impl="QT-07" quickfix="false" scope="line" severity="1">
            <file path="QT\QT-07.rule"/>
         </rule>
         <rule header="If using lock on a mutex in a function, release the lock in the same function" id="08" impl="QT-08" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-08.rule"/>
         </rule>
         <rule header="Do not call new on QMutexLocker" id="09" impl="QT-09" quickfix="false" scope="line" severity="1">
            <file path="QT\QT-09.rule"/>
         </rule>
         <rule header="Declare a copy constructor and operator= for any Qt - inherited objects that have pointers" id="10" impl="QT-10" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-10.rule"/>
         </rule>
         <rule header="Do not use setWindowFlags function on a Widget" id="11" impl="QT-11" quickfix="false" scope="line" severity="4">
            <file path="QT\QT-11.rule"/>
         </rule>
         <rule header="Do not directly set specific Widget attributes that are set by Qt kernel" id="12" impl="QT-12" quickfix="false" scope="line" severity="1">
            <file path="QT\QT-12.rule"/>
         </rule>
         <rule header="Never mix const and non-const iterators in assignment" id="13" impl="QT-13" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-13.rule"/>
         </rule>
         <rule header="If you use Q_DECLARE_FLAGS, you must also use Q_DECLARE_OPERATORS_FOR_FLAGS" id="14" impl="QT-14" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-14.rule"/>
         </rule>
         <rule header="Q_DECLARE_OPERATORS_FOR_FLAGS must be in the global namespace, Q_DECLARE_FLAGS inside the enum's namespace" id="15" impl="QT-15" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-15.rule"/>
         </rule>
         <rule header="The getters and setters of a Q_PROPERTY must exist and the types must match" id="16" impl="QT-16" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-16.rule"/>
         </rule>
         <rule header="Properties of enum types must use Q_ENUMS" id="17" impl="QT-17" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-17.rule"/>
         </rule>
         <rule header="Non-const function should not be called on the Qt object" id="18" impl="QT-18" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-18.rule"/>
         </rule>
      </category>
      <category description="Security" name="SECURITY">
         <rule header="Avoid functions which use time from standard C library" id="01" impl="SECURITY-01" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-01.rule"/>
         </rule>
         <rule header="Avoid functions which use random numbers from standard C library" id="02" impl="SECURITY-02" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-02.rule"/>
         </rule>
         <rule header="Do not use the rand() function for generating pseudorandom numbers" id="02_b" impl="SECURITY-02_b" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-02_b.rule"/>
         </rule>
         <rule header="Usage of system properties (environment variables) should be restricted" id="03" impl="SECURITY-03" quickfix="false" scope="line" severity="4">
            <file path="SECURITY\SECURITY-03.rule"/>
         </rule>
         <rule header="Use care to ensure that LoadLibrary() will load the correct library" id="04" impl="SECURITY-04" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-04.rule"/>
         </rule>
         <rule header="Avoid calling functions printf/wprintf with only one argument other than string constant" id="05" impl="SECURITY-05" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-05.rule"/>
         </rule>
         <rule header="Avoid functions which use time from MFC library" id="06" impl="SECURITY-06" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-06.rule"/>
         </rule>
         <rule header="Don't use unsafe C functions that do write to range-unchecked buffers" id="07" impl="SECURITY-07" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-07.rule"/>
         </rule>
         <rule header="Avoid using functions fprintf/fwprintf with only two parameters, when second parameter is a variable" id="08" impl="SECURITY-08" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-08.rule"/>
         </rule>
         <rule header="Avoid using data() function from 'string' class of standard library" id="09" impl="SECURITY-09" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-09.rule"/>
         </rule>
         <rule header="Avoid using the 'vfork()' function" id="10" impl="SECURITY-10" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-10.rule"/>
         </rule>
         <rule header="Avoid using unsecured shell functions that may be affected by shell metacharacters" id="11" impl="SECURITY-11" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-11.rule"/>
         </rule>
         <rule header="Avoid using unsafe string functions which may cause buffer overflows" id="12" impl="SECURITY-12" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-12.rule"/>
         </rule>
         <rule header="Avoid using unsafe string functions that do not check bounds" id="13" impl="SECURITY-13" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-13.rule"/>
         </rule>
         <rule header="Do not use scanf and fscanf functions without specifying variable size in format string" id="14" impl="SECURITY-14" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-14.rule"/>
         </rule>
         <rule header="Do not print potentially sensitive information, resulting from an application error into exception messages" id="15" impl="SECURITY-15" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-15.rule"/>
         </rule>
         <rule header="Never use gets()" id="16" impl="SECURITY-16" quickfix="false" scope="line" severity="1">
            <file path="SECURITY\SECURITY-16.rule"/>
         </rule>
         <rule header="Avoid passing non-const parameters or variables into exec" id="17" impl="SECURITY-17" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-17.rule"/>
         </rule>
         <rule header="Avoid passing dynamically created strings into exec" id="18" impl="SECURITY-18" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-18.rule"/>
         </rule>
         <rule header="Usage of functions prone to race is not allowed" id="19" impl="SECURITY-19" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-19.rule"/>
         </rule>
         <rule header="Avoid passing user input into methods as parameters" id="20" impl="SECURITY-20" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-20.rule"/>
         </rule>
         <rule header="Do not use 'syslog' function for logging purposes" id="21" impl="SECURITY-21" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-21.rule"/>
         </rule>
         <rule header="Do not use mbstowcs() function" id="22" impl="SECURITY-22" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-22.rule"/>
         </rule>
         <rule header="Beware of functions which may return the current directory or the windows directory" id="23" impl="SECURITY-23" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-23.rule"/>
         </rule>
         <rule header="Avoid using InitializeCriticalSection" id="24" impl="SECURITY-24" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-24.rule"/>
         </rule>
         <rule header="Avoid using thread-unsafe functions" id="25" impl="SECURITY-25" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-25.rule"/>
         </rule>
         <rule header="Do not use 'setuid' in source code" id="26" impl="SECURITY-26" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-26.rule"/>
         </rule>
         <rule header="Don't use chmod(), chown(), chgrp()" id="27" impl="SECURITY-27" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-27.rule"/>
         </rule>
         <rule header="Standard random number generators should not be used to generate randomness for security reasons" id="28" impl="SECURITY-28" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-28.rule"/>
         </rule>
         <rule header="Do not use obsolete C routine ulimit()" id="29" impl="SECURITY-29" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-29.rule"/>
         </rule>
         <rule header="Avoid using 'getpw' function in program code" id="30" impl="SECURITY-30" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-30.rule"/>
         </rule>
         <rule header="Do not use 'cuserid' function" id="31" impl="SECURITY-31" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-31.rule"/>
         </rule>
         <rule header="Avoid using obsolete C routine 'usleep'" id="32" impl="SECURITY-32" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-32.rule"/>
         </rule>
         <rule header="Usage of functions which do not properly handle non-NULL terminated strings is not allowed" id="33" impl="SECURITY-33" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-33.rule"/>
         </rule>
         <rule header="Avoid using environment variables" id="34" impl="SECURITY-34" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-34.rule"/>
         </rule>
         <rule header="Don't trust any value of command line if attacker can set them" id="35" impl="SECURITY-35" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-35.rule"/>
         </rule>
         <rule header="Never use unfiltered data from an untrusted user as the format parameter" id="36" impl="SECURITY-36" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-36.rule"/>
         </rule>
         <rule header="Do not use weak encryption functions" id="37" impl="SECURITY-37" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-37.rule"/>
         </rule>
         <rule header="Untrusted data is used as a loop boundary" id="38" impl="SECURITY-38" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-38.rule"/>
         </rule>
         <rule header="Use secure temporary file name functions" id="39" impl="SECURITY-39" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-39.rule"/>
         </rule>
         <rule header="Call 'umask' before calling 'mkstemp'" id="40" impl="SECURITY-40" quickfix="false" scope="line" severity="4">
            <file path="SECURITY\SECURITY-40.rule"/>
         </rule>
         <rule header="Call 'chdir' if you call 'chroot'" id="41" impl="SECURITY-41" quickfix="false" scope="line" severity="4">
            <file path="SECURITY\SECURITY-41.rule"/>
         </rule>
         <rule header="Specify the access permission bits if a file is created using the 'open' or 'openat' system call" id="42" impl="SECURITY-42" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-42.rule"/>
         </rule>
         <rule header="The function 'pthread_setcanceltype()' should not be called with 'PTHREAD_CANCEL_ASYNCHRONOUS' argument" id="43" impl="SECURITY-43" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-43.rule"/>
         </rule>
         <rule header="Observe correct revocation order while relinquishing privileges" id="44" impl="SECURITY-44" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-44.rule"/>
         </rule>
         <rule header="Ensure that privilege relinquishment is successful" id="45" impl="SECURITY-45" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-45.rule"/>
         </rule>
         <rule header="A pointer to a structure should not be passed to a function that can copy data to the user space" id="46" impl="SECURITY-46" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-46.rule"/>
         </rule>
         <rule header="Use correct integer precisions when checking the right hand operand of the shift operator" id="47" impl="SECURITY-47" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-47.rule"/>
         </rule>
         <rule header="Do not call system()" id="48" impl="SECURITY-48" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-48.rule"/>
         </rule>
         <rule header="Use the 'cnd_signal()' function with a unique condition variable" id="49" impl="SECURITY-49" quickfix="false" scope="line" severity="4">
            <file path="SECURITY\SECURITY-49.rule"/>
         </rule>
         <rule header="Do not use the 'notify_one()' function when multiple threads are waiting on the same condition variable" id="50" impl="SECURITY-50" quickfix="false" scope="line" severity="4">
            <file path="SECURITY\SECURITY-50.rule"/>
         </rule>
      </category>
      <category description="STL Best Practices" name="STL">
         <rule header="Instead of trying to write the container-independent code use class encapsulation" id="01" impl="STL-01" quickfix="false" scope="line" severity="5">
            <file path="STL\STL-01.rule"/>
         </rule>
         <rule header="To make copying efficient, correct, and immune to the slicing problem create containers of pointers instead of containers of objects" id="02" impl="STL-02" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-02.rule"/>
         </rule>
         <rule header="Call empty instead of checking size() against zero" id="03" impl="STL-03" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-03.rule"/>
         </rule>
         <rule header="Avoid using iterative calls to insert in an explicit loop" id="04" impl="STL-04" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-04.rule"/>
         </rule>
         <rule header="Almost all uses of copy where the destination range is specified using an insert iterator should be replaced with calls to range member functions" id="05" impl="STL-05" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-05.rule"/>
         </rule>
         <rule header="Instead of anonymous istream_iterator objects use istream_iterator names when used as function parameters" id="06" impl="STL-06" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-06.rule"/>
         </rule>
         <rule header="When using containers of newed pointers, remember to delete the pointers before the container is destroyed" id="07" impl="STL-07" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-07.rule"/>
         </rule>
         <rule header="Never create containers of auto_ptrs" id="08" impl="STL-08" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-08.rule"/>
         </rule>
         <rule header="Avoid using remove algorithm with list and standard associative containers" id="09" impl="STL-09" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-09.rule"/>
         </rule>
         <rule header="Prefer vector and string to dynamically allocated arrays" id="10" impl="STL-10" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-10.rule"/>
         </rule>
         <rule header="Consider using vector&lt;char&gt; instead of string" id="11" impl="STL-11" quickfix="false" scope="line" severity="4">
            <file path="STL\STL-11.rule"/>
         </rule>
         <rule header="Use reserve to avoid unnecessary reallocations" id="12" impl="STL-12" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-12.rule"/>
         </rule>
         <rule header="Each vector and string should be checked if it is not empty before it is passed to C function" id="13" impl="STL-13" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-13.rule"/>
         </rule>
         <rule header="Avoid using vector&lt;bool&gt;" id="14" impl="STL-14" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-14.rule"/>
         </rule>
         <rule header="Specify comparison types for associative containers of pointers" id="15" impl="STL-15" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-15.rule"/>
         </rule>
         <rule header="For associative containers never use comparison function returning true for equal values" id="16" impl="STL-16" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-16.rule"/>
         </rule>
         <rule header="For associative containers never use comparison function returning true for equal values" id="17" impl="STL-17" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-17.rule"/>
         </rule>
         <rule header="Prefer iterator to const iterator, reverse_iterator, and const_reverse_iterator" id="18" impl="STL-18" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-18.rule"/>
         </rule>
         <rule header="Use distance and advance to convert a container's const_iterators to iterators" id="19" impl="STL-19" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-19.rule"/>
         </rule>
         <rule header="It is necessary to be careful when using reverse_iterator's base iterator for erasure purposes" id="20" impl="STL-20" quickfix="false" scope="line" severity="4">
            <file path="STL\STL-20.rule"/>
         </rule>
         <rule header="Consider istreambuf_iterators for character-by-character input" id="21" impl="STL-21" quickfix="false" scope="line" severity="4">
            <file path="STL\STL-21.rule"/>
         </rule>
         <rule header="Make sure destination ranges are big enough" id="22" impl="STL-22" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-22.rule"/>
         </rule>
         <rule header="Follow remove-like algorithms by erase if you really want to remove something" id="23" impl="STL-23" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-23.rule"/>
         </rule>
         <rule header="Avoid using remove and similar algorithms (i.e., remove_if and unique) on containers of dynamically allocated pointers" id="24" impl="STL-24" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-24.rule"/>
         </rule>
         <rule header="If you pass a sorted range to an algorithm that also takes a comparison function, be sure that the comparison function you pass behaves the same as the one you used to sort the range" id="25" impl="STL-25" quickfix="false" scope="line" severity="4">
            <file path="STL\STL-25.rule"/>
         </rule>
         <rule header="Proper implementation of copy_if should not be based on returning the remove_copy_if with a not1 in front of the predicate" id="26" impl="STL-26" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-26.rule"/>
         </rule>
         <rule header="If accumulate() is used on a container of floating point values, use floating point value as initial one" id="27" impl="STL-27" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-27.rule"/>
         </rule>
         <rule header="Design functor classes for pass-by-value" id="28" impl="STL-28" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-28.rule"/>
         </rule>
         <rule header="Make predicates const pure functions" id="29" impl="STL-29" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-29.rule"/>
         </rule>
         <rule header="Each functor class should has only one operator() function, and it's parameter and return types should be passed to unary_function or binary_function" id="30" impl="STL-30" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-30.rule"/>
         </rule>
         <rule header="You must employ ptr_fun, mem_fun, or mem_fun_ref whenever you pass a function to an STL component" id="31" impl="STL-31" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-31.rule"/>
         </rule>
         <rule header="Make sure less&lt;T&gt; means operator&lt;" id="32" impl="STL-32" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-32.rule"/>
         </rule>
         <rule header="Prefer algorithm calls to hand-written loops" id="33" impl="STL-33" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-33.rule"/>
         </rule>
         <rule header="Prefer member functions to algorithms with the same names" id="34" impl="STL-34" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-34.rule"/>
         </rule>
         <rule header="Do not rely on the conversion of count()'s nonzero values to true and zero to false" id="35" impl="STL-35" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-35.rule"/>
         </rule>
         <rule header="Do not use an iterator range that isn't really a range" id="36" impl="STL-36" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-36.rule"/>
         </rule>
         <rule header="Use vector and string instead of arrays" id="37" impl="STL-37" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-37.rule"/>
         </rule>
         <rule header="Use != instead of &lt; to compare iterators" id="38" impl="STL-38" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-38.rule"/>
         </rule>
         <rule header="Use traits classes in conjunction with overloading" id="39" impl="STL-39" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-39.rule"/>
         </rule>
         <rule header="When calling swap, employ a using declaration for std::swap, then call swap without namespace qualification" id="40" impl="STL-40" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-40.rule"/>
         </rule>
         <rule header="Do not declare the non-member to be an overloading of std::swap" id="41" impl="STL-41" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-41.rule"/>
         </rule>
         <rule header="Member version of swap should never throw exceptions" id="42" impl="STL-42" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-42.rule"/>
         </rule>
      </category>
      <category description="Template" name="TEMPL">
         <rule header="Factor parameter-independent code out of templates" id="01" impl="TEMPL-01" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-01.rule"/>
         </rule>
         <rule header="Define non-member functions inside templates when type conversions are desired" id="02" impl="TEMPL-02" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-02.rule"/>
         </rule>
         <rule header="Do not overload functions within a template class" id="03" impl="TEMPL-03" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-03.rule"/>
         </rule>
         <rule header="In template global functions use 'typename' to identify nested dependent type names" id="04" impl="TEMPL-04" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-04.rule"/>
         </rule>
         <rule header="In template classes use 'typename' to identify nested dependent type names" id="05" impl="TEMPL-05" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-05.rule"/>
         </rule>
         <rule header="Don't change default arguments of virtual functions in template classes" id="06" impl="TEMPL-06" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-06.rule"/>
         </rule>
         <rule header="A copy constructor shall be declared when there is a template constructor with a single parameter that is a generic parameter" id="07" impl="TEMPL-07" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-07.rule"/>
         </rule>
         <rule header="The viable function set for a function call should either contain no function specializations, or only contain function specializations" id="08" impl="TEMPL-08" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-08.rule"/>
         </rule>
         <rule header="Overloaded function templates shall not be explicitly specialized" id="09" impl="TEMPL-09" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-09.rule"/>
         </rule>
         <rule header="All partial and explicit specializations for a template shall be declared in the same file as the declaration of their primary template" id="10" impl="TEMPL-10" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-10.rule"/>
         </rule>
         <rule header="A copy assignment operator shall be declared when there is a template assignment operator with a parameter that is a generic parameter" id="11" impl="TEMPL-11" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-11.rule"/>
         </rule>
         <rule header="In a class template with a dependent base, any name that may be found in that dependent base shall be referred to using a qualified-id or this-&gt;" id="12" impl="TEMPL-12" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-12.rule"/>
         </rule>
         <rule header="Do not declare non-member generic functions in associated namespaces" id="13" impl="TEMPL-13" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-13.rule"/>
         </rule>
         <rule header="The function shall resolve to a function declared previously in the translation unit" id="14" impl="TEMPL-14" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-14.rule"/>
         </rule>
         <rule header="Declare 'extern' an explicitly instantiated template" id="15" impl="TEMPL-15" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-15.rule"/>
         </rule>
         <rule header="Template specialization shall be declared in the same file as the primary template or a user-defined type, for which the specialization is declared" id="16" impl="TEMPL-16" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-16.rule"/>
         </rule>
      </category>
   </builtin>
</rules>
